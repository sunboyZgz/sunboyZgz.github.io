<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>君の名は</title>
    <link href="/2023/05/28/your-name/"/>
    <url>/2023/05/28/your-name/</url>
    
    <content type="html"><![CDATA[<h1 id="きみのなは"><a href="#きみのなは" class="headerlink" title="きみのなは"></a>きみのなは</h1><p>由于最近考研很无聊，同时又不想只是反反复复地过每一天，因此抽了一天看看李清照与你的名字，关于李清照我只是看了一个短视频，作了简要的了解，因为我年轻时贪玩且只知道玩电子游戏所以对文学相关的知识知之甚少，而我重温了高一时期所看的《你的名字》，上次以电影的形式与之相识，这次以小说的形式与之再回。</p><p>小说中对于人物特征和心理的描述让我多年前印在脑海中的画面更加具体，同时对整个电影中的细节也有了更详细的认识。</p><p><img src="https://newblog-zgz.oss-cn-hangzhou.aliyuncs.com/post-cover/book.jpg"></p><p>我最爱的一个镜头</p><p><a href="https://www.bilibili.com/video/BV1BN4y1L7q7/?spm_id_from=trigger_reload&vd_source=7ec098be7aa3a99d69991580c3f8b447">https://www.bilibili.com/video/BV1BN4y1L7q7/?spm_id_from=trigger_reload&amp;vd_source=7ec098be7aa3a99d69991580c3f8b447</a></p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让生活更有情调</title>
    <link href="/2023/05/02/first-beach-experience/"/>
    <url>/2023/05/02/first-beach-experience/</url>
    
    <content type="html"><![CDATA[<h1 id="不再是个只读书的机器人"><a href="#不再是个只读书的机器人" class="headerlink" title="不再是个只读书的机器人"></a>不再是个只读书的机器人</h1><h4 id="令人悲伤的现实"><a href="#令人悲伤的现实" class="headerlink" title="令人悲伤的现实"></a>令人悲伤的现实</h4><p>就在去年以chat-gpt为代表的<em>大规模AI语言模型</em>掀起了一股浪潮，人们可以用对话的方式通过这个聊天ai获取到自己想要的信息，随着训练文本量级的不断提升ai算法的精准度也已经越来越高。技术的革新给人们带来了许多遍历与新的体验，但是在聊天中我又感到了悲伤，就最简单的而言虽然他只是根据训练数据获取到较为自由的输入与输出，但是在某些方面比我这个应试的学生做的好太多了。当今发展之下，机器人比人更像一个有独立思考能力的人，而人则像机器人式地去根据一个输入得出一个输出，这是一件可悲的事情。虽然我不能代表所有人，但是我应该能代表大部分的普通本科生。</p><h4 id="让自己的生活中不只有读书"><a href="#让自己的生活中不只有读书" class="headerlink" title="让自己的生活中不只有读书"></a>让自己的生活中不只有读书</h4><p>由于最近被自己的菜鸟技术水平所影响，当我静下心来思考了上述的问题后，一种抑郁的感情在心底油然而生。我好好细想机器人、ai与人的不同，我发现意识形态的东西真的非常重要，当下那些苦读书，将读书与未来挂钩的学生也已经越来越多，虽然我也是认为读书是一条翻身路，但是他不是未来成就一番的充分条件。以读书为借口逃避社交，逃避人潮人海的商业街区一直都是我的惯用手段。虽然我是个看重素质培养的人，但是本身的社交能力短板是不可否认的，另外我也是一个不擅长用出门娱乐来放松自己的人。所以这个五一，我打算从出门开始，一是调整学习心态，二是跨出这些人生成长上的关键步调。</p><h4 id="第一次的海滩之旅"><a href="#第一次的海滩之旅" class="headerlink" title="第一次的海滩之旅"></a>第一次的海滩之旅</h4><p>作为一个农村小伙，这一天确实值得纪念，疫情大开放后的第一个传统节日的假期，4.30号的这一天有许多难忘的第一次，第一次体验朱家尖的金色沙滩，第一次体验完全瘫痪的交通(即使交警极力疏通仍旧用了4小时才开完了原本半小时的路程)，第一次体验舟山的海鲜，第一次在门禁之后回到校园。不过，体验过集中式的放假我以后应该不会在类似的日子去名胜景区，虽然瘫痪的交通令人难忘，但确实影响了出门休假的体验。另外有点遗憾的是，因为时间没有安排好，买的景区票只玩了两个景点。</p><h1 id="すずめの戸締まり"><a href="#すずめの戸締まり" class="headerlink" title="すずめの戸締まり"></a>すずめの戸締まり</h1><p>事实上本次五一金色沙滩的决定是室友临时想到的，我本人最为期待的是新海诚的新作《铃芽之旅》。于是在5.1这天我一个人去观看了这部令人期待的作品。</p><p>我认为本部作品是灾难三部曲中对于人世间情感体现最佳的一部，虽然它不及《你的名字》陨石坠地两人穿梭时空相互拯救的浪漫，不及《天气之子》灾难之中抗争世界的果决，但是这部作品才是灾难系世界系作品应该有的样子，其中情感无需观众身临其境便能感受。地震不像陨石坠落不像极端的暴雨倾盆，铃芽之旅以一种人们及其熟悉的并仍然有许多幸存者与之息息相关的自然灾害来展现受灾地区人们的不幸以及幸存者们的顽强，其他的感情如社会的温情，恋情，人们心中的沉重，怨情，人们的不屈与向前看的勇气都体现的淋漓尽致。这不是单单纯纯的二人关门之旅，这是一部以小见大，融入世界的作品。</p><h2 id="首先需要提及的是一些背景设定："><a href="#首先需要提及的是一些背景设定：" class="headerlink" title="首先需要提及的是一些背景设定："></a>首先需要提及的是一些背景设定：</h2><p><strong>女主角铃芽的人设</strong></p><p>是遭遇童年创伤的311大地震幸存者。2011年3月11日，日本东北部仙台发生9.0级大地震，引发了空前的大海啸和核泄露，致使22118人死亡或从此失踪。铃芽家位于震源地，她的母亲也成了遇难者。失去至亲的铃芽，只好与姨妈搬到日本南部的乡下九州，尘封起相关的记忆，其实这也是一种心门，直到故事的最后看到“常生”中的小铃芽走出了那扇门我才知道铃芽看似在门外其实她一直在门内。</p><p><strong>“往门”的寓意</strong></p><p>每处废墟里的“往门”，都是近代日本曾经发生过7级以上大规模地震的源头。全片的主线，可以被概括成是一场少女回溯“日本地震史”的旅程。铃芽每次关门，都是一次纪念与祷告。</p><p>“往门”其实还对应着一道道“家门”与“心门”。门里藏的，是过往的悲恸。而门外等着的，是人与人之间的温暖善意，也是我们必须收拾好自己、努力活下去的信念。</p><p><strong>草太的咒语</strong></p><p>草太呼唤日不见神和土地神出来镇压“蚓厄”，这是一段与神明沟通的咒语。“日不见”指生活在地下的鼬鼠，它们以蚯蚓为食，对“蚓厄”有震慑力。此外，草太也需要向土地神强调：人是百代之过客。</p><p>废墟不只存在于现实，也存在于许多人的心中。废墟里包含了受灾幸存者的挂念，以及罹难者的记忆。新海诚以此咒语，表达对土地的敬意、对罹难者的缅怀。</p><p><strong>大臣</strong></p><p>如果把大臣理解成是一个孩童天性的人，而不是一个反派，他的动机就变得非常简单。铃芽不小心把他放到人世，他重见天日，幻想能和铃芽成为家人。新一轮的“蚓厄”来袭，大臣本想让草太替自己完成使命，最终却牵引着命定之人（铃芽）到达了“常世”。</p><h2 id="内容与深意"><a href="#内容与深意" class="headerlink" title="内容与深意"></a>内容与深意</h2><p><strong>三条腿的椅子</strong></p><p>新海诚也提到，关于椅子的另一个隐喻是：最近几年，很多年轻一代都感到被困住、被束缚。他想把人们的困顿感，投射到草太被封印进椅子里这个设定上。</p><p><strong>姨妈爆发出心底的阴暗面</strong></p><p>左大臣通过心灵控制的方式，让姨妈透露出心底的苦恼。在这12年的生活中，姨妈与铃芽生活在一起，彼此都没法把自己的真心话说出来，久而久之，反而导致了铃芽成长路上的心理障碍。为了解决这个问题，左大臣才插手此事。这样做虽会伤害彼此，但这些伤人的话被直白地说出来，反而促使铃芽能够向前再迈开一步。</p><p>此外，姨妈追着铃芽奔走，恰好对应了左大臣追着大臣想要弥补错失。两组角色都陷入了代际问题当中。</p><p><strong>铃芽在“常世”里见到幼时的自己</strong></p><p>铃芽之所以踏上这趟旅程，是因为那个救赎幼时自己的人就是她本人。只有自己了解自己的痛苦与欢乐，也只有自己能做出真正的选择。当她说出“未来并不可怕，我是铃芽的明天”时，那一刻我才理解到，铃芽逐渐走出内心的创伤，并非是因为发生了什么奇迹，而是因为她在这12年间，平凡、普通，而又努力地活着。</p><p><strong>“我出发了。”</strong></p><p>这是《铃芽》里最常出现的台词，也是日本文化语境里最常用的话。短短四个字，却包含了很多层意思。地震当日，每个说出这句话的人，可能都再也无法重新见到家人。这句话成了他们之间的最后一句话。</p><p>所谓灾难，就是说出“我出发了”之后，再也无法说出“我回来了”的时刻。逝者的亲人不仅要承受这份失去的痛苦，还要承受回忆的重压。所以每当关门时，铃芽都会听到当地人们源自生活的声音，悉心感受门里那些日常生活的记忆与情感。</p><p>而这也是新海诚透过电影想让我们铭记的——日常的一个个纪念性瞬间、那些珍贵的情感瞬间，它们不会轻易消失。即使离世，也仍会给世界留下印记。还活着的人，不会忘记他们，不会忘记那些记忆，会一直温柔地记住，并不断出发，去驱散阴霾。</p><p>正如草太所言，“我知道命如蜉蝣，死亡如影随形，但我依旧祈祷，哪怕只是再多一年、再多一天、再多一时，我们也想要活下去。”</p><hr><img src="https://newblog-zgz.oss-cn-hangzhou.aliyuncs.com/post-cover/5-1%E6%9C%B1%E5%AE%B6%E5%B0%96.jpg" style="zoom:50%;" /><p>每个靠自己的意志走出至暗时刻的人，每个努力做自我修复的人，应该都会对《铃芽之旅》产生很深很深的共鸣。</p><p>「你今后也会喜欢上别人，也会遇到许多很喜欢妳的人。虽然你现在可能觉得一片黑暗，可是早晨总是会来临。」</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>里奥·梅西</title>
    <link href="/2022/12/19/lionel-messi/"/>
    <url>/2022/12/19/lionel-messi/</url>
    
    <content type="html"><![CDATA[<h1 id="里奥·梅西"><a href="#里奥·梅西" class="headerlink" title="里奥·梅西"></a>里奥·梅西</h1><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%88%A9%E6%98%82%E5%86%85%E5%B0%94%C2%B7%E6%A2%85%E8%A5%BF">https://zh.wikipedia.org/wiki/%E5%88%A9%E6%98%82%E5%86%85%E5%B0%94%C2%B7%E6%A2%85%E8%A5%BF</a></p></blockquote><p>这篇文章我将记录一下我刚迷上的这位男人，首先我没有任何的足球知识，更不是一位足球迷，我只是近期世界杯接近尾声时开始看各种视频集锦。但我发现这位身高170cm左右但是盘带过人、射门精准的射手时我先是为之球技所吸引。这时我只是被他年轻时人球合一的一种姿态所吸引。</p><p>比如这个视频：<a href="https://www.bilibili.com/video/BV19W4y1g7JS/">https://www.bilibili.com/video/BV19W4y1g7JS/</a></p><p>我看了许许多多这类的视频，慢慢地我开始对他这个人的生平事迹感兴趣，于是我开始寻找与之相关的故事。</p><p>比如这个视频：<a href="https://www.bilibili.com/video/BV1L24y1f71Z/">https://www.bilibili.com/video/BV1L24y1f71Z/</a></p><p>在我看来他能达到现在的成就与之天赋、努力、性格还有家庭密不可分。</p><p>梅西在2022&#x2F;12&#x2F;18世界杯决赛前-2022&#x2F;12&#x2F;19手捧大力神神杯前获奖无数（我能说获奖无数，因为我只是最近刚刚迷上了他短短3天），老一代的球员对他赞誉有加，新一代的球迷也很容易被他年轻时的能力所吸引。但他有多次遗憾(多次与大力神杯擦肩而过)，那么大力神杯对他而言是什么呢？首先在我看来，他的个人能力之出众根本无需大力神杯的证明，那么他为什么宁可把所有的奖项甚至荣誉用来换一个大力神杯。这里就要从阿根廷这个国家以及他们的足球历史来说了，简单而言就是阿根廷需要这个奖项来证明他们自己，就如时隔28年获得的美洲杯冠军一样，这个时隔36年的大力神杯在某种程度上代表了一国的荣誉。梅西将如此重担抗在肩头，顶着如此重大的压力拼劲全力地去踢好每一场球赛，不仅深深地吸引着我，也使得阿根廷球队有了一个绝对的核心和支撑，有一个小细节就是梅西凡是点球总是抗在第一个，从一个不懂球的观众角度来看，这既是振奋军心的一球，也是沉重的一球，但作为球队的领袖他始终抗住这样的压力。梅西的魅力不仅在于他年轻时出色的个人能力，也在于他在35岁这个年纪更加沉稳的心态，以及能够将一个球队拧成一股绳的领袖能力。</p><p><a href="https://www.bilibili.com/video/BV1Rd4y1P7Xv/">https://www.bilibili.com/video/BV1Rd4y1P7Xv/</a></p><p>另外，这次的决赛让我看到了新一代球星的韧性，在法国队状态低迷的前80分钟，他们并没有被击溃。并且在80分钟后完成了一次又一次的反击，姆巴佩也将继续书写他在新一代球星中的风采。</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更换我的手机电池</title>
    <link href="/2022/11/14/change-mobile-battery/"/>
    <url>/2022/11/14/change-mobile-battery/</url>
    
    <content type="html"><![CDATA[<h1 id="更换电池"><a href="#更换电池" class="headerlink" title="更换电池"></a>更换电池</h1><h4 id="事情起因"><a href="#事情起因" class="headerlink" title="事情起因"></a>事情起因</h4><p>因为我有剥手机壳的坏习惯，剥着剥着，哎呀，我就发现了手机后盖闭合不紧密，但是这可不是一个简单的问题，一般来说手机中没有突起部分手机后盖与机体的粘胶是可以保证非常久的密封性的，所以我下意识地就想到了电池鼓包的情况，当然我没有什么特别的依据是证明这件事。由于我的手机也已经用了4年之久了，所以我这次决定拆开它一探究竟。</p><h4 id="勇气是第一步"><a href="#勇气是第一步" class="headerlink" title="勇气是第一步"></a>勇气是第一步</h4><p>每一个人小时候或多或少都会拆掉几个玩具，看到啥新鲜东西就想往嘴里塞。不知道什么时候，我们失去了年幼时那份挑战未知的勇气，得到了更多的“真理”，我们就会越缺失对问题的质疑。幼时我们拆掉玩具根本不会担心它会不会坏，当然有时我们能将它重组，有时我们只能将它扔到垃圾桶里。我认为学习一点简答的拆卸是需要的，一年前我拆了笔记本后盖装了两个风扇，卸下cpu涂上硅脂，虽然是件微不足道的小事，但是很多人会担心自己完不成而不敢下手。有些人则是不愿意去学习相关的知识，花钱交给了相关人士。所以这次我依旧秉承我的旧风格：“能自己完成的小事绝对不交’智商税‘”。</p><h4 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h4><img src="https://newblog-zgz.oss-cn-hangzhou.aliyuncs.com/post-content/change-battery1.jpg" style="zoom: 25%;" /><img src="https://newblog-zgz.oss-cn-hangzhou.aliyuncs.com/post-content/change-battery3.jpg" style="zoom:25%;" /><img src="https://newblog-zgz.oss-cn-hangzhou.aliyuncs.com/post-content/change-battery2.jpg" style="zoom:25%;" />]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动手</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rust-move-borrow</title>
    <link href="/2022/10/16/rust-move-borrow/"/>
    <url>/2022/10/16/rust-move-borrow/</url>
    
    <content type="html"><![CDATA[<h1 id="一题看所有权问题"><a href="#一题看所有权问题" class="headerlink" title="一题看所有权问题"></a>一题看所有权问题</h1><h2 id="写文原因"><a href="#写文原因" class="headerlink" title="写文原因"></a>写文原因</h2><p>众所周知，在rust中所有权问题是一个非常重要的问题，他直接影响了一个程序的性能。另外配合上rust的检查器+rust的生命周期，他能在很多情况下及时反馈出程序的潜在问题，这篇文章将会用一个leetcode题目分析一下如何在编写程序的时候进行合理的思考。  </p><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists">https://leetcode.cn/problems/merge-two-sorted-lists</a></p><p><strong>【注】：</strong>本文并不是算的讲解，最好在能够思考出算法的实现方案下阅读。</p><h2 id="move与borrow"><a href="#move与borrow" class="headerlink" title="move与borrow"></a>move与borrow</h2><p>关于变量表达式的问题：<a href="https://doc.rust-lang.org/reference/expressions.html?highlight=move#place-expressions-and-value-expressions">https://doc.rust-lang.org/reference/expressions.html?highlight=move#place-expressions-and-value-expressions</a></p><p><strong>关于这页相关理论，下面这句话尤为需要注意，这句话在循环中能起到非常大的作用。</strong></p><blockquote><p>After moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized</p></blockquote><p>关于所有权的理论在这个链接中有详细的说明：<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</a></p><p>下面我们简单的讲一下，接下来需要的理论</p><h4 id="1-所有权"><a href="#1-所有权" class="headerlink" title="1.所有权"></a>1.所有权</h4><p>对于一个临时且不是reference的变量我们可以认为我们拥有了它的所有权，此时对于我们声明的变量我们可以认为我们拥有了它的所有权，变量内存地址位置就会开辟出装载该变量所需要的内存空间。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="2-可变性"><a href="#2-可变性" class="headerlink" title="2.可变性"></a>2.可变性</h4><p>默认情况下rust视为我们不能对变量的内存空间进行操作，即使拥有所有权依旧需要<code>mut</code>pattern来提供可操作该区域内存空间的能力。即使你是房子的主人，也需要先用钥匙打开房子的门。嗯！没错，就是这种感觉。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>node.next = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>)));<br><span class="hljs-comment">//下面是没有mut编译器的报错</span><br><span class="hljs-comment">//cannot assign to `node.next`, as `node` is not declared as mutable cannot assign</span><br></code></pre></td></tr></table></figure><h4 id="3-不可变借用"><a href="#3-不可变借用" class="headerlink" title="3.不可变借用"></a>3.不可变借用</h4><p>借用这个概念真的非常贴近我们日常的表述了，就是东西我借给你了，但是你要原模原样得还给我。</p><p>在代码中，我们可以理解为将数据内存空间的读取能力分发给了其他变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">node2</span> = &amp;node;<br></code></pre></td></tr></table></figure><h4 id="4-可变借用"><a href="#4-可变借用" class="headerlink" title="4.可变借用"></a>4.可变借用</h4><p>与不可变借用相似，提供了可修改原有数据内存空间的能力。东西仍然在我这里，但是你修改之后，我也这边也产生了变化。</p><p>但是在这种借用前，这个东西首先是能够修改的，也就是绑定了<code>mut</code> pattern。另外可变借用的操作符号是<code>&amp;mut</code>。</p><p>这篇官文也说明了使用可变借用的其他性质：<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;node.val);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">node2</span> = &amp;<span class="hljs-keyword">mut</span> node;<br>node2.val = <span class="hljs-number">2</span>;<br><span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, node.val);<br></code></pre></td></tr></table></figure><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>优秀的代码在产出前一定有很多的思考，但是在产出之前rust会让你增加对于代码结构编织的思考，不然你就可能只能将伪代码保存在你的脑子里了。对于我们这样的新手如果不认真思考的话就不是项目规模化后的问题了，而是能不能让编译器爸爸放你过关😂。</p><h4 id="算法简析：对于两条链合并情况的分析"><a href="#算法简析：对于两条链合并情况的分析" class="headerlink" title="算法简析：对于两条链合并情况的分析"></a>算法简析：对于两条链合并情况的分析</h4><ol><li>两条空链</li><li>只有一条 链&#x2F;子链 存在</li><li>两条 链&#x2F;子链 都存在</li></ol><h4 id="将思路具体化"><a href="#将思路具体化" class="headerlink" title="将思路具体化"></a>将思路具体化</h4><p>1.创建防止第一个节点就是NULL而无法正确执行算法的辅助节点</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">head</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(-<span class="hljs-number">101</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = &amp;<span class="hljs-keyword">mut</span> head; <span class="hljs-comment">//cur变量的内存地址中应该要记录当前连接到的最后一个节点，另外最后一个点就是cur记录的是一个地址，但是我们在拼接时需要修改这个地址，而不单单是修改地址所指的数据空间。</span><br>...<br>head.next<br></code></pre></td></tr></table></figure><p>2.在两条子链都存在的情况下进行的拼接操作</p><p>While let expression:<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops">https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops</a></p><p>Match expression: <a href="https://doc.rust-lang.org/reference/expressions/match-expr.html">https://doc.rust-lang.org/reference/expressions/match-expr.html</a></p><blockquote><p>If the scrutinee expression is a <a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">value expression</a>, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found.</p></blockquote><p>针对这个问题我们可以做出以下两种思考</p><p>思考一：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(n1), <span class="hljs-title function_ invoke__">Some</span>(n2)) = (&amp;list1, &amp;list2) &#123;<span class="hljs-comment">//在这里使用借用，这样不会导致list的所有权转移到这里，然后后面就会无法访问list1，list2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考二：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(n1), <span class="hljs-title function_ invoke__">Some</span>(n2)) = (list1, list2) &#123;<span class="hljs-comment">//这就是转移所有权并使用tuple pattern进行结构赋值，这样n1，n2所有权也在当前作用域下。但是使用这种方案我们需要进行一点修改，因为这样的所有权解构会造成list1，list2无法在后续访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.取小的节点进行拼接</p><p>思考一的body</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(n1), <span class="hljs-title function_ invoke__">Some</span>(n2)) = (&amp;list1, &amp;list2) &#123;<span class="hljs-comment">//list1在未重分配前会飘红</span><br><span class="hljs-keyword">if</span> n1.val &lt; n2.val &#123;<br>      cur.next = list1; <span class="hljs-comment">//1.这里move进去，当我们写到这里在IDE环境我们会发现 &amp;list1 这里出现 borrow after move的飘红报错，这时请用好上面说到的 重分配理论，请自信使用为list1分配一个所有权的value的代码</span><br>      cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();  <span class="hljs-comment">//因为cur是一个可变借用，所以需要一个可变借用</span><br>      list1 = cur.next.<span class="hljs-title function_ invoke__">take</span>(); <span class="hljs-comment">//2.从cur.next这里move出来，并未list1重分配</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//相同道理</span><br>  &#125;<br>&#125;<br>cur.next = <span class="hljs-keyword">if</span> list1.<span class="hljs-title function_ invoke__">is_some</span>() &#123; list1 &#125; <span class="hljs-keyword">else</span> &#123; list2 &#125;;<br></code></pre></td></tr></table></figure><p>思考二的body</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-keyword">if</span> list1.<span class="hljs-title function_ invoke__">is_some</span>() &amp;&amp; list2.<span class="hljs-title function_ invoke__">is_some</span>() &#123;<span class="hljs-comment">//这么做是为了防止while let最后一次解构引起后续list1，list2无法borrow的问题</span><br>        <span class="hljs-keyword">let</span> (n1, n2) = (list1.<span class="hljs-title function_ invoke__">unwrap</span>(), list2.<span class="hljs-title function_ invoke__">unwrap</span>());<br>        <span class="hljs-keyword">if</span> &amp;n1.val &lt; &amp;n2.val &#123;<br>            cur.next = <span class="hljs-title function_ invoke__">Some</span>(n1);<br>            cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            list1 = cur.next.<span class="hljs-title function_ invoke__">take</span>();<br>            list2 = <span class="hljs-title function_ invoke__">Some</span>(n2)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//相同道理</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br>cur.next = <span class="hljs-keyword">if</span> list1.<span class="hljs-title function_ invoke__">is_some</span>() &#123; list1 &#125; <span class="hljs-keyword">else</span> &#123; list2 &#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在rust代码的编写中我们需要更多地去思考，而不是过度依赖于编译器，要做到有理有据。过度依赖编译器很容易不自信啦。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮点数总结</title>
    <link href="/2022/10/12/float-numeric/"/>
    <url>/2022/10/12/float-numeric/</url>
    
    <content type="html"><![CDATA[<h1 id="浮点数与其构成"><a href="#浮点数与其构成" class="headerlink" title="浮点数与其构成"></a>浮点数与其构成</h1><h2 id="为什么学习浮点数？"><a href="#为什么学习浮点数？" class="headerlink" title="为什么学习浮点数？"></a>为什么学习浮点数？</h2><p>对于浮点数，我一直都是抱着深入其基础实现的想法，但是之前一直没有进行底层知识的学习。终于在这几周，我开始恶补底层的知识，虽然对于大部分人来说浮点数以及对于浮点数的操作都不需要知道其内部的实现，不过我认为我们可以不用去实现，但是作为知识面我们至少还是要了解一二的。</p><p>比如在程序语言中经常可以看到的问题：0.1 + 0.2 !&#x3D; 0.3 问题。</p><p>当然上面这个问题归根到底主要是小数在二进制中的计算方案采用一种乘2取1的方法</p><h2 id="浮点数的基本格式"><a href="#浮点数的基本格式" class="headerlink" title="浮点数的基本格式"></a>浮点数的基本格式</h2><p>我们知道计算机底层对于数的表示都是 <code>0101xxxx...</code> 这样的二进制码，在整数的二进制中我们将有符号数的存储单元(这里所说的存储单元与int32 &#x3D; 4 bytes对应)最高位置设为符号位，1表示整个数为负数。</p><h4 id="十进制如何进行浮点数表示"><a href="#十进制如何进行浮点数表示" class="headerlink" title="十进制如何进行浮点数表示"></a>十进制如何进行浮点数表示</h4><p>例如：</p><ul><li>0.000001 &#x3D; 1.0 * 10^-6</li><li>30000 &#x3D; 3.0 * 10^4</li></ul><h4 id="二进制浮点数表示"><a href="#二进制浮点数表示" class="headerlink" title="二进制浮点数表示"></a>二进制浮点数表示</h4><p>所以我们可以对这种认识进行二进制翻译</p><p>1.0 * 10^6 &#x3D; 1 * binary(10^-6)</p><p>3.0 * 10^4 &#x3D; 11 * binary(10^4)</p><h4 id="存储在计算机里的二进制浮点数表示"><a href="#存储在计算机里的二进制浮点数表示" class="headerlink" title="存储在计算机里的二进制浮点数表示"></a>存储在计算机里的二进制浮点数表示</h4><p>但是我们不能将一个表达式直接存储在计算机中，虽然我认为是有办法可以做到，但是这并不划算，所以我们需要一套性价比更高的方案。</p><p>于是乎我们就需要去制定一套存储格式，去规定浮点数的正负，指数次数，以及实际有效的数。</p><p>另外我们也可以发现对于30000这样的数字我们也可以表示为30 * 10^3 &#x3D;&#x3D; 3 * 10^4,而我们称等号右边是对等号左边的规格化，同理二进制也可以做这样的规格化，因为二进制只有0和1，所以我们只会在左边数为1的时候进行一次移位，这样我们省下这一位的空间了，为浮点数提供更大的表达范围。</p><p>浮点数的三部分：<code>符号位</code>，<code>指数段</code>，<code>尾数段</code>。值得一提的是，浮点数的符号位这种表示与整数符号位的设计思维并不一样。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">浮点数 = (-<span class="hljs-number">1</span>)^<span class="hljs-variable">S</span> * <span class="hljs-function"><span class="hljs-title">fraction</span>(尾数) * <span class="hljs-number">2</span>^<span class="hljs-title">exponent</span>(指数)</span><br></code></pre></td></tr></table></figure><p>以下是 IEEE754标准的f32</p><table><thead><tr><th>31</th><th>30</th><th>29</th><th>28</th><th>27</th><th>26</th><th>25</th><th>24</th><th>23</th><th>22</th><th>21</th><th>20</th><th>19</th><th>18</th><th>17</th><th>16</th><th>15</th><th>14</th><th>13</th><th>12</th></tr></thead><tbody><tr><td>符号位</td><td>exponent</td><td></td><td></td><td></td><td></td><td></td><td></td><td>exponent</td><td>fraction</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>fraction</td></tr></tbody></table><h2 id="具体的计算"><a href="#具体的计算" class="headerlink" title="具体的计算"></a>具体的计算</h2><p>1.如果0，32位存储全为0</p><p>2.如果不为零，进行上述的计算方案，负数在符号位置1，进行二进制的计算将思维中的十进制浮点数转换为二进制。</p><p>计算机底层如何处理我不清楚，这里我根据浮点数的算数处理留下以下结论：</p><ul><li>如果存在整数位，exponent &#x3D; 整数位的位数 - 1, fraction 扔掉最高位的1</li><li>如果不存在整数位，我们需要找到小数位二进制的第一个1，1前面的0 以 exponent &#x3D; 0的数量 来表示</li></ul><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>为了更简单的得到反馈：我使用了浏览器为载体，下面是我的代码仓库</p><p><a href="https://github.com/sunboyZgz/interesting/blob/main/src/components/009.vue">https://github.com/sunboyZgz/interesting/blob/main/src/components/009.vue</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机底层知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awesome-rust-1(IdentifierPattern)</title>
    <link href="/2022/09/23/awesome-rust-1/"/>
    <url>/2022/09/23/awesome-rust-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust-IdentifierPattern-ref"><a href="#Rust-IdentifierPattern-ref" class="headerlink" title="Rust IdentifierPattern - ref"></a>Rust <em>IdentifierPattern</em> - ref</h1><h2 id="rust-启动！"><a href="#rust-启动！" class="headerlink" title="rust 启动！"></a>rust 启动！</h2><p>这是awesome-rust的第一篇文章，所有文章的内容都将以问题由来+问题解决+官文链接的方案来解释（当然由于个人能力问题官文中的内容可能不能理解到位，请海涵）。</p><p>rust的官方reference：<a href="https://doc.rust-lang.org/reference/introduction.html">https://doc.rust-lang.org/reference/introduction.html</a> 。我认为所有学习rust的同学都应该知道这份参考手册的存在，这份手册真的是太棒辣。</p><h2 id="IdentifierPattern"><a href="#IdentifierPattern" class="headerlink" title="IdentifierPattern"></a><em>IdentifierPattern</em></h2><h4 id="问题产出"><a href="#问题产出" class="headerlink" title="问题产出"></a>问题产出</h4><p>我在<code>codewars</code>平台进行练习题目 [ <a href="https://www.codewars.com/kata/52bef5e3588c56132c0003bc">https://www.codewars.com/kata/52bef5e3588c56132c0003bc</a> ] 后与他人代码对比后发现了 <code>ref</code> 正确使用的姿势之一。</p><p>这里值得提一嘴的是，对于刚步入一门新语言的“萌新”，<code>codewars</code>的题目推荐非常适合用于熟悉语言特点与语言标准库。</p><p>下面这个是Node的struct，同时Node并没有实现<code>Clone</code>或者<code>Copy</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    value: <span class="hljs-type">u32</span>,<br>    left: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;,<br>    right: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h4><p><strong>我的代码</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">traverse</span>(last_nodes: &amp;<span class="hljs-keyword">mut</span> VecDeque&lt;&amp;Node&gt;, result: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt;) &#123;<br>    <span class="hljs-keyword">if</span> last_nodes.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">childrens</span> = VecDeque::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = last_nodes.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>      result.<span class="hljs-title function_ invoke__">push</span>(node.value);<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(n) = &amp;node.left &#123;<br>          childrens.<span class="hljs-title function_ invoke__">push_back</span>(n.<span class="hljs-title function_ invoke__">as_ref</span>());<br>      &#125;<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(n) = &amp;node.right &#123;<br>          childrens.<span class="hljs-title function_ invoke__">push_back</span>(n.<span class="hljs-title function_ invoke__">as_ref</span>());<br>      &#125;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">traverse</span>(&amp;<span class="hljs-keyword">mut</span> childrens, result)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他人的代码</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tree_by_levels_best</span>(root: &amp;Node) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">queue</span>: VecDeque&lt;&amp;Node&gt; = VecDeque::<span class="hljs-title function_ invoke__">from</span>([root]);<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(n) = queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>        result.<span class="hljs-title function_ invoke__">push</span>(n.value);<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> l) = n.left &#123; <span class="hljs-comment">//关键的不同点</span><br>            queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> r) = n.right &#123;<br>            queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*r);<br>        &#125;<br>    &#125;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>由于平时常用的<code>IdentifierPattern</code>多是 <code>mut</code>,而这里出现了 <code>ref</code>，虽然从字面上或者代码上我们可以理解 <code>ref</code> 的作用，但是我还是想要找出使用这个 pattern 的条件。 </p><p>官文链接：<a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">https://doc.rust-lang.org/reference/patterns.html#identifier-patterns</a> 。</p><p>官文中明确指出了，标识符的pattern默认的两种做法</p><p>1.会优先考虑把标识符所表示的变量绑定到它所依赖的值的一份copy上。</p><p>2.会优先考虑把依赖数据move到变量中</p><p>关于copy，当然就是实现 Rust的 <code>Copy Trait</code>咯。</p><p>关于move，这里贴出官文的链接：<a href="https://doc.rust-lang.org/reference/expressions.html?highlight=move#moved-and-copied-types">https://doc.rust-lang.org/reference/expressions.html?highlight=move#moved-and-copied-types</a> ，这里面提出了能够move的四种情况。在这里我认为不能进行move的主要原因是第一种情况</p><blockquote><p><a href="https://doc.rust-lang.org/reference/variables.html">Variables</a> which are not currently borrowed.</p></blockquote><p>这里摘出关键的不同点进行拆分</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> l) = n.left &#123; <br>    queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有 <code>ref</code>，代码会以以下方式呈现，当rust的编译器进行checker时会发现我们的Node节点没有Copy的实现，同时在<code>Some(l) = n.left</code>这个<code>destructuring subpatterns</code>中发现l依赖的数据是<code>Box&lt;Node&gt;</code> 关于<code>Box</code>它相当于是一种共享型的能力，因此也并不满足<code>move</code>触发的条件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(l) = n.left &#123; <br>    queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有了上面的<code>ref</code>我们会改变 identifier pattern 的默认绑定方式，相当于采用了下面的做法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(l) = &amp;n.left &#123; <br>    queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，我在这个学习的过程中还发现了一个有趣的问题，就是rust的自动类型推测系统与实际需要效果的差异。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">queue</span>: VecDeque&lt;&amp;Node&gt; = VecDeque::<span class="hljs-title function_ invoke__">from</span>([root]); <span class="hljs-comment">//这里是显示类型</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">childrens</span> = VecDeque::<span class="hljs-title function_ invoke__">new</span>(); <span class="hljs-comment">//这里会infer出 VecDeque&lt;&amp;Box&lt;Node&gt;&gt;,与实际需求略有差异</span><br>...<br>childrens.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*n);<br>...<br></code></pre></td></tr></table></figure><p>欢迎各位前来指点，这是我的SO Question: <a href="https://stackoverflow.com/questions/73824648/rust-why-compiler-infers-a-different-type-beyond-our-expection">https://stackoverflow.com/questions/73824648/rust-why-compiler-infers-a-different-type-beyond-our-expection</a></p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文入门rust iterator</title>
    <link href="/2022/09/21/rust-iter/"/>
    <url>/2022/09/21/rust-iter/</url>
    
    <content type="html"><![CDATA[<h1 id="一文入门rust-iterator"><a href="#一文入门rust-iterator" class="headerlink" title="一文入门rust iterator"></a>一文入门rust iterator</h1><h2 id="1-本文由来"><a href="#1-本文由来" class="headerlink" title="1.本文由来"></a>1.本文由来</h2><p>秉承一贯的做法，我还是想说说为什么我会想要写下这篇文章。起因是这样的，作为一名刚想rust的新手，我找到了一个锻炼rust语法比较好的平台<code>codewars</code>，当然我在之前就已经阅读了rust最优质的文章资源：<a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">https://doc.rust-lang.org/book/ch01-00-getting-started.html</a> ，以及使用过<code>rustlings</code>进行了一些的知识点检查。在锻炼的过程中，我发现那些简短而优雅的代码不仅仅是逻辑运用更加熟练，同时他们对于标准库的掌握与熟悉程度也是非常得高。</p><h2 id="2-一个简单的入门级rust-iterator"><a href="#2-一个简单的入门级rust-iterator" class="headerlink" title="2.一个简单的入门级rust iterator"></a>2.一个简单的入门级rust iterator</h2><h4 id="1-让我们自己进行便利操作我们会怎么做？"><a href="#1-让我们自己进行便利操作我们会怎么做？" class="headerlink" title="1.让我们自己进行便利操作我们会怎么做？"></a>1.让我们自己进行便利操作我们会怎么做？</h4><p>假设我们有以下这样的结构，我们如果要遍历并对每个元素进行相应的操作时应该怎么做？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    elms: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">struct Bag&lt;T&gt; (Vec&lt;T&gt;) 这种结构也可以，主要是为了不直接使用Vec，只使用他的装载功能</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="2-大部分人可能的做法"><a href="#2-大部分人可能的做法" class="headerlink" title="2.大部分人可能的做法"></a>2.大部分人可能的做法</h4><p>如果让我们自己来进行实现，我们认为对于一个新手来说最容易想到的就是，实现可以传入闭包的“方法”。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">traverse</span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-title function_ invoke__">Fn</span>(T, <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (),<br>    &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-title function_ invoke__">f</span>(<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">get</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">clone</span>(), i);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-问题分析"><a href="#3-问题分析" class="headerlink" title="3.问题分析"></a>3.问题分析</h4><p>以上做法没有问题，并且能够实现特别多的需求但是上面的做法在不连续的遍历中就显得别不是那么得灵活。如果想要一种可以完全控制其遍历进度并且充分灵活的方案就需要迭代器的加入。</p><p>跟随着官网对于迭代器的实现，我在最开始实现了以下一个错误案例。</p><p><strong>注意：</strong>这是错误案例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    elms: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>    idx: <span class="hljs-type">usize</span>,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Copy</span>&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.idx &lt; <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-keyword">self</span>.idx).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">clone</span>());<br>            <span class="hljs-keyword">self</span>.idx += <span class="hljs-number">1</span>;<br>            result<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个问题中我们会发现，我们可以进行迭代，但是问题是我们的迭代只能遍历一次，因为<code>idx</code>的索引值会越界。这个时候有人会说在遍历到最后一个的时候重置索引值，这样可行但是如果我们同时需要两个Bag的迭代器呢？ok，有人会说为<code>Bag</code>提供<code>Clone Trait</code>，但是这样的问题就是不必要的内存开辟。</p><p>所以对于<code>Iterator</code>，我们应该将他看成是一个独立的个体，但同时他又必须与需要遍历的对象保持一定的联系。</p><h4 id="4-最终的简单方案"><a href="#4-最终的简单方案" class="headerlink" title="4.最终的简单方案"></a>4.最终的简单方案</h4><p>1.首先我们需要一个独立的遍历器</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BagIter</span>&lt;T&gt; &#123;<br>    idx: <span class="hljs-type">usize</span>,<span class="hljs-comment">//这是独立的访问索引</span><br>    elms: Rc&lt;RefCell&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt;&gt;, <span class="hljs-comment">//记录我们需要遍历的context</span><br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; BagIter&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elms: Rc&lt;RefCell&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        BagIter &#123; idx: <span class="hljs-number">0</span>, elms &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">BagIter</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>    T: <span class="hljs-built_in">Copy</span>,<br>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">elms</span> = <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">borrow</span>();<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.idx &lt; elms.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-literal">true</span> =&gt; <span class="hljs-keyword">match</span> elms.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-keyword">self</span>.idx) &#123;<br>                <span class="hljs-title function_ invoke__">Some</span>(&amp;x) =&gt; &#123;<br>                    <span class="hljs-keyword">self</span>.idx += <span class="hljs-number">1</span>;<br>                    <span class="hljs-title function_ invoke__">Some</span>(x)<br>                &#125;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>            &#125;,<br>            <span class="hljs-literal">false</span> =&gt; <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.实现一个 <code>iter</code> 每次调用 <code>iter()</code>生成一个新的独立遍历器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    elms: Rc&lt;RefCell&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt;&gt;,<br>&#125;<br><span class="hljs-comment">//can only put things into Bag</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Bag&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, item: T) &#123;<br>        <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(item)<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Bag&lt;T&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">elms</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[]));<br>        Bag &#123; elms: elms &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">size</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">borrow</span>().<span class="hljs-title function_ invoke__">len</span>()<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iter</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> BagIter&lt;T&gt; &#123;<br>        BagIter::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">clone</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-满足你的-for-…-in-expression"><a href="#5-满足你的-for-…-in-expression" class="headerlink" title="5.满足你的 for … in expression"></a>5.满足你的 for … in expression</h4><p>众所周知在一套完美的第三方库或者标准库下，rust为第三方开发者提供的体验是非常优越的，其主要源自<code>Trait</code>以及一些隐式编译的实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Copy</span>&gt; <span class="hljs-built_in">IntoIterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">IntoIter</span> = BagIter&lt;T&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into_iter</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::IntoIter &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">iter</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>IntoIterator</code>可以让你的代码在编译时生成对于self.iter()的迭代器。另外根据<code>IntoIterator for &amp;mut Bag&lt;T&gt;</code>, <code>IntoIterator for &amp; Bag&lt;T&gt;</code>的不同也可以实现不同的借用、修改迭代器，当然咯，这个都是得重写一份逻辑的。</p><p>ok，希望这篇入门能够帮你建立如何编写迭代器的认知。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片像素化</title>
    <link href="/2022/09/14/pixel-image/"/>
    <url>/2022/09/14/pixel-image/</url>
    
    <content type="html"><![CDATA[<h1 id="像素化一张图片"><a href="#像素化一张图片" class="headerlink" title="像素化一张图片"></a>像素化一张图片</h1><h2 id="1-为什么我会想要一种像素风格的图片"><a href="#1-为什么我会想要一种像素风格的图片" class="headerlink" title="1.为什么我会想要一种像素风格的图片"></a>1.为什么我会想要一种像素风格的图片</h2><p>因为我前段时间想要DIY一个便携的显示器，直接一个面板+驱动的方案看上去不但造型不行，而且不易携带。于是我就在网上搜索，我发现了可自定义化程度最高的就是面板+驱动+微积木方案了，但是自定义的像素风格图片去哪找呢，于是我就想要一个这样的效果。</p><h2 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h2><p>这边我采用的是在浏览器这个平台进行操作，一个原因是使用其他语言我需要去学习对应的库，第二个就是在浏览器这个平台上我能够更快地得到反馈。</p><h4 id="1-关于屏幕上的像素点"><a href="#1-关于屏幕上的像素点" class="headerlink" title="1.关于屏幕上的像素点"></a>1.关于屏幕上的像素点</h4><p>通过分辨率的设定，我们可以在屏幕上划分出不同的行、列可显示的像素数，比如同样的<code>300 * 300</code></p><p>像素的图片在，<code>2560 * 1440</code> 和 <code>1920 * 1080</code>的分辨率下默认的显示大小是不同，这种时候屏幕一格的像素大小就产生了差异。</p><h4 id="2-曾经与现在"><a href="#2-曾经与现在" class="headerlink" title="2.曾经与现在"></a>2.曾经与现在</h4><p>现在的屏幕往往在最低的分辨率下，屏幕划分好的一个像素点也比以前的屏幕要小了不知道多少倍，目前我们可以假设：一个曾经的像素点 &#x3D; 一个现在的像素点 * 9 * 9。</p><h4 id="3-屏幕展示像素数量多的好处"><a href="#3-屏幕展示像素数量多的好处" class="headerlink" title="3.屏幕展示像素数量多的好处"></a>3.屏幕展示像素数量多的好处</h4><p>显而易见，像素数就是一个区域色彩展示的层度，更多的像素数可以体现出更加细节的处理。因为像素是方格的，越小的像素点可以是的方格与方格之间过渡更加的平滑。整体的细节处理就更加优秀。</p><h4 id="4-关于我们使用操作系统放大图片"><a href="#4-关于我们使用操作系统放大图片" class="headerlink" title="4.关于我们使用操作系统放大图片"></a>4.关于我们使用操作系统放大图片</h4><p>关于这一点，我的理解是：操作系统放大图片的处理其实是对图片中每个实际像素的逻辑扩大，也就是图片源文件其实是不变的，但是我们再放大时其实是在使用临时的图片文件，然后我们对源文件的每个像素进行采样并进行新的映射，比如原来的 1个像素映射成 2*2个像素区的逻辑像素。</p><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3.具体实现"></a>3.具体实现</h2><p>看了上面的操作，实际上我们就可以有初步的方案了，也就是对图片进行缩小的采样与扩大的映射。</p><h4 id="1-使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）"><a href="#1-使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）" class="headerlink" title="1.使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）"></a>1.使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）</h4><ol><li>将图片缩小并画到画布上。</li><li>将画布上的图片画到临时图片DOM上。</li><li>将临时的图片DOM画到与图片原来尺寸相同甚至更大的画布上。</li></ol><p>在上述的操作中图片的采样以及映射均由浏览器为我们实现。</p><p>具体代码：scale为采样间隔或者说缩放比例，影响采样频率。</p><p><img src="/2022/09/14/pixel-image/js.png" alt="image-20220914130850306"></p><h4 id="2-使用自己实现的逻辑方案。"><a href="#2-使用自己实现的逻辑方案。" class="headerlink" title="2.使用自己实现的逻辑方案。"></a>2.使用自己实现的逻辑方案。</h4><p>1.每隔多少行多少列(gap)进行一次采样</p><p>2.对采样后的像素进行映射,映射大小为 1像素 &#x3D; <code>gap * gap</code> 像素</p><p>因为图片的资源占用量比较大。</p><p>具体可以参考：<a href="https://github.com/sunboyZgz/pixel-image/blob/56c54ccdbc526c72a7ef607b41a1bb1f07831aff/packages/pixel-image/src/main.ts#L47">https://github.com/sunboyZgz/pixel-image/blob/56c54ccdbc526c72a7ef607b41a1bb1f07831aff/packages/pixel-image/src/main.ts#L47</a></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的博客</title>
    <link href="/2022/08/24/newblog/"/>
    <url>/2022/08/24/newblog/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-Page-Custom-Domain"><a href="#Github-Page-Custom-Domain" class="headerlink" title="Github Page-Custom Domain"></a>Github Page-Custom Domain</h1><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h2><p>众所周知<code>github</code>提供了一个<code>github-page</code>的服务，但是有些人很困惑为什么只能部署一个项目，但其实并不是这样的。<code>github-page</code>setting中的<code>custom domain</code>能很好的利用这个服务为我们部署多个项目。</p><p>本质上是利用<code>github</code>为每一个用户提供的一个个人站点(<code>username.github.io</code>)（相当于提供了静态服务器已经一个绑定的域名），进行<code>DNS</code>映射这样就能在剩下服务器的时候进行一些个人项目部署。</p><h2 id="2-具体操作"><a href="#2-具体操作" class="headerlink" title="2.具体操作"></a>2.具体操作</h2><h4 id="1-首先我们需要一个域名"><a href="#1-首先我们需要一个域名" class="headerlink" title="1.首先我们需要一个域名"></a>1.首先我们需要一个域名</h4><p>如何获取域名自行解决，我是在阿里收购的域名提供商那边买的</p><h4 id="2-进行域名解析，使username-github-io与你购买的一级域相映射"><a href="#2-进行域名解析，使username-github-io与你购买的一级域相映射" class="headerlink" title="2.进行域名解析，使username.github.io与你购买的一级域相映射"></a>2.进行域名解析，使<code>username.github.io</code>与你购买的一级域相映射</h4><p>这一步我是在阿里云的域名解析里做的，其他方式大同小异</p><p>1.在域名解析里采用CNAME的形式将一个对我自己的域名（zhugezhen.cn)和<code>sunboyzgz.github.io</code></p><p>进行一个映射。</p><p>下一步在<strong>setting</strong>中的<strong>pages</strong>设置中操作</p><p>2.在<strong>Build and deployment</strong>的<strong>source</strong>选项下选择<strong>deploy from a branch</strong>，然后选择你要部署的目录，也就是你希望展示的<code>index.html</code>所存在的目录。不同于<code>deploy from a branch</code>github也为我们提供了一个<strong>github actions</strong>的选择，这里就是后面要讲的<code>github actions</code>。</p><p>3.选择一个<code>custom domain</code>这里就是我们自己购买的域名填入即可</p><p><strong>note</strong>!!: 使用二级域名与<code>custom domain</code>相互映射的方案我们可以部署多个项目，并且这些项目并不需要都在<code>username.github.io</code>这个仓库下, 不过二级域名也是直接映射到<code>username.github.io</code>这个域。</p><p>这里假设我们的生成的二级域名是<code>book.zhugezhen.cn</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//域名解析中 CNAME形式，当然也可以使用ip的形式</span><br>zhugezhen<span class="hljs-selector-class">.cn</span> -&gt; sunboyzgz<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br>book<span class="hljs-selector-class">.zhugezhen</span><span class="hljs-selector-class">.cn</span> -&gt; sunboyzgz<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br><span class="hljs-comment">//setting pages CNAME</span><br>custom domain save <span class="hljs-selector-tag">a</span> zhugezhen<span class="hljs-selector-class">.cn</span><br>custom domain save <span class="hljs-selector-tag">a</span> book<span class="hljs-selector-class">.zhugezhen</span>.cn<br></code></pre></td></tr></table></figure><h1 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h1><h2 id="1-原因-1"><a href="#1-原因-1" class="headerlink" title="1.原因"></a>1.原因</h2><p>本质上，这就是github为我们提供的一个CI&#x2F;CD的能力</p><p>在<code>hexo</code>生成的blog项目中，我们虽然可以在本地进行<code>generate</code>然后将源代码同步到远程仓库的一个分支，然后再将需要展示的文件目录推送到另一个分支，但是这样会在每次操作时需要进行很多相同的重复操作。这项工作可以交给其他的工具进行比如<a href="https://github.com/marketplace/travis-ci">Travis CI</a>，我只是抱着学习的态度想要尝试一下<code>action</code>。</p><h2 id="2-如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案"><a href="#2-如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案" class="headerlink" title="2.如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案"></a>2.如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span> <span class="hljs-string">blog</span> <span class="hljs-string">to</span> <span class="hljs-string">gh-pages</span>  <span class="hljs-comment">#这个是一个workflow name</span><br><span class="hljs-attr">on:</span> <span class="hljs-comment">#监听push的事件</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> <span class="hljs-comment">#对于main分支的push事件进行监听</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><span class="hljs-attr">jobs:</span> <span class="hljs-comment">#workflow中的jobs列表，jobs默认并发进行，如需相互依赖参考 need 属性的使用</span><br>  <span class="hljs-attr">generate-public:</span> <span class="hljs-comment">#job name</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span> <span class="hljs-comment">#运行的操作系统</span><br>    <span class="hljs-attr">steps:</span> <span class="hljs-comment">#操作步骤一步一步向下执行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span> <span class="hljs-comment">#使用checkout action，提供摘取仓库的能力</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span> <span class="hljs-comment">#一个配置node环境的action</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-number">16</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">packages</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-comment">#就像在本地用使用命令行一样</span><br>        <span class="hljs-comment">#这里要说一下，一个name下只能拥有一个run，有时可以像以下这样执行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">generate</span> <span class="hljs-string">public</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npx</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">npx</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">CNAME</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#x27;zhugezhen.cn&#x27;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">./public/CNAME</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span> <span class="hljs-comment">#将目标目录push gh-pages分支的action</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br></code></pre></td></tr></table></figure><p>这个<code>github actions</code>的配置其实就已经代替了<code>hexo</code>文档中<a href="https://hexo.io/zh-cn/docs/github-pages%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%E4%BA%86%E3%80%82">https://hexo.io/zh-cn/docs/github-pages的操作说明了。</a></p><h4 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h4><p>1.请先了解github actions:<a href="https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions">https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions</a></p><p>2.可以看看这里面的基本使用：<a href="https://github.com/jaywcjlove/github-actions">https://github.com/jaywcjlove/github-actions</a></p><p>3.这个不重要随便看看就好：<a href="https://github.blog/2022-08-10-github-pages-now-uses-actions-by-default/">https://github.blog/2022-08-10-github-pages-now-uses-actions-by-default/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的篇章</title>
    <link href="/2022/08/23/My-new-way/"/>
    <url>/2022/08/23/My-new-way/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么会有这篇文章？"><a href="#为什么会有这篇文章？" class="headerlink" title="为什么会有这篇文章？"></a>为什么会有这篇文章？</h1><p>由于最近c盘紧张，我重装了一次系统同进行了一些卷容量的调整，因为最近没有怎么写过blog在进行格式化的时候将原来搭建的个人blog给清除了而且也没有做备份，git page上传的也只是一个经过处理后的html文件，所以我原来的blog文件都丢失了。因为我需要进行一些环境配置，所以写下了这篇文章。</p><h1 id="nodejs-npm-pnpm-配置"><a href="#nodejs-npm-pnpm-配置" class="headerlink" title="nodejs + npm + pnpm 配置"></a>nodejs + npm + pnpm 配置</h1><h2 id="1-windows-下安装nodejs"><a href="#1-windows-下安装nodejs" class="headerlink" title="1.windows 下安装nodejs"></a>1.windows 下安装nodejs</h2><p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>按照步骤安装即可，注意一下nodejs的安装目录即可</p><h2 id="2-配置npm"><a href="#2-配置npm" class="headerlink" title="2.配置npm"></a>2.配置npm</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config get prefix<br></code></pre></td></tr></table></figure><p>这条命令可以直接获取你的全局安装路径的前缀,这个前缀会用于</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> xxxx<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;D:\Program Files\nodejs\node_global&quot;</span><br><br>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\Program Files\nodejs\node_cache&quot;</span><br></code></pre></td></tr></table></figure><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><ol><li></li></ol><p><code>NODE_PATH    D:\Program Files\nodejs\node_global\node_modules</code></p><p><code>NODE_PATH</code> 用于进行全局的模块检索，例如加载npm全局下的<code>express</code>模块的时候</p><ol start="2"><li></li></ol><p><code>PATHD D:\Program Files\nodejs\node_global</code></p><h2 id="3-配置pnpm"><a href="#3-配置pnpm" class="headerlink" title="3.配置pnpm"></a>3.配置pnpm</h2><p>注意此项可以不用配置，在没有配置的情况下会在当前卷的根目录创建<code>node_modules</code>进行管理。</p><p>如果想要pnpm跨磁盘或者卷进行管理可以按如下设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm config <span class="hljs-built_in">set</span> store<span class="hljs-literal">-dir</span> /path/to/.pnpm<span class="hljs-literal">-store</span><br></code></pre></td></tr></table></figure><p>参考链接：<a href="https://www.pnpm.cn/configuring%E3%80%81https://www.pnpm.cn/faq#store-path-is-not-specified">https://www.pnpm.cn/configuring、https://www.pnpm.cn/faq#store-path-is-not-specified</a></p><h4 id="4-修改install的镜像源"><a href="#4-修改install的镜像源" class="headerlink" title="4.修改install的镜像源"></a>4.修改install的镜像源</h4><p>这里就是淘宝的，要是用别的请搜索对应uri</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config get registry<br></code></pre></td></tr></table></figure><h1 id="python-anaconda"><a href="#python-anaconda" class="headerlink" title="python anaconda"></a>python anaconda</h1><h2 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1.安装anaconda"></a>1.安装anaconda</h2><p>大陆用户推荐用清华的源进行安装解决安装包下载过慢的问题</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><h2 id="2-解决一些典型问题（待补充）"><a href="#2-解决一些典型问题（待补充）" class="headerlink" title="2.解决一些典型问题（待补充）"></a>2.解决一些典型问题（待补充）</h2><h4 id="1-pip-is-configured-with-locations-that-require-TLS-SSL"><a href="#1-pip-is-configured-with-locations-that-require-TLS-SSL" class="headerlink" title="1.[pip is configured with locations that require TLS/SSL]"></a>1.<code>[pip is configured with locations that require TLS/SSL]</code></h4><p><a href="https://stackoverflow.com/questions/45954528/pip-is-configured-with-locations-that-require-tls-ssl-however-the-ssl-module-in">https://stackoverflow.com/questions/45954528/pip-is-configured-with-locations-that-require-tls-ssl-however-the-ssl-module-in</a></p><p>一般我们都会把 python解释器和pip的路径加入环境，但是这里我们也需要加入第三个路径到环境中。（这里需要的原因可能是我在使用anaconda这个发型版本）</p><h2 id="3-修改local-cache"><a href="#3-修改local-cache" class="headerlink" title="3.修改local cache"></a>3.修改local cache</h2><p>下面这篇博文讲述了为什么需要这个cache</p><p><a href="https://www.techiediaries.com/python-pip-local-cache/">https://www.techiediaries.com/python-pip-local-cache/</a></p><p>配置方法:在<code>%HOME%</code>的<code>pip</code>目录下创建<code>pip.ini</code>（没有目录就自建一个）</p><p>找到<code>%HOME%</code>, 可以在文件资源管理器的路径栏输入<code>homepath</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[global]</span><br><span class="hljs-attr">cache-dir</span> = E:/languages/anaconda3/mypip/cache<br><span class="hljs-attr">log-file</span> = E:/languages/anaconda3/mypip/pip.log<br></code></pre></td></tr></table></figure><h2 id="4-修改pip安装源"><a href="#4-修改pip安装源" class="headerlink" title="4.修改pip安装源"></a>4.修改pip安装源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p><h4 id="5-检查一下配置情况"><a href="#5-检查一下配置情况" class="headerlink" title="5. 检查一下配置情况"></a>5. 检查一下配置情况</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip config list<br></code></pre></td></tr></table></figure><p><img src="/2022/08/23/My-new-way/image-20220823141458429.png" alt="result image"></p><h2 id="6-2022-x2F-8-x2F-27补充"><a href="#6-2022-x2F-8-x2F-27补充" class="headerlink" title="6. 2022&#x2F;8&#x2F;27补充:"></a>6. 2022&#x2F;8&#x2F;27补充:</h2><p>error:</p><blockquote><p>solving environment: failed with intitial frozen solve.Retrying with flexible solve.</p></blockquote><p><img src="/2022/08/23/My-new-way/image-20220827185106780.png" alt="error image"></p><h4 id="方案一：直面困难"><a href="#方案一：直面困难" class="headerlink" title="方案一：直面困难"></a>方案一：直面困难</h4><p>1.修改<code>conda</code>安装的镜像源为后续操作提速</p><p>具体修改方案可以参考清华提供的方案<code>.condarc</code></p><p>windows下使用命令生成在<code>%home%</code>目录下生成</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">conda config <span class="hljs-literal">--set</span> show_channel_urls yes<br></code></pre></td></tr></table></figure><p>然后将下方链接的中的配置复制到<code>.condarc</code>中</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p><p>2. </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">conda update <span class="hljs-literal">-all</span><br></code></pre></td></tr></table></figure><h4 id="方案二：曲线救国"><a href="#方案二：曲线救国" class="headerlink" title="方案二：曲线救国"></a>方案二：曲线救国</h4><p>使用pip install 安装，但是这样的话不能享受到conda create env带来的好处。但是真的简单。</p><h4 id="方案三：降级conda策略"><a href="#方案三：降级conda策略" class="headerlink" title="方案三：降级conda策略"></a>方案三：降级conda策略</h4><p>网上自搜</p><h1 id="go"><a href="#go" class="headerlink" title="go"></a>go</h1><p>这个就是最为简单的了</p><p>去官网找个安装包跟着官网走就好了：<a href="https://go.dev/doc/install">https://go.dev/doc/install</a></p><p>安装好之后推荐修改一下<code>GOPATH</code>和<code>GOBIN</code>,目前版本<code> GO111MODULE</code>默认是设为<code>on</code></p><p>小小的看一下<code>GOPATH</code>的目录结构，以及功能：<a href="http://c.biancheng.net/view/88.html">http://c.biancheng.net/view/88.html</a></p><h2 id="1-在（用户环境变量）中修改GOPATH"><a href="#1-在（用户环境变量）中修改GOPATH" class="headerlink" title="1.在（用户环境变量）中修改GOPATH"></a>1.在（用户环境变量）中修改GOPATH</h2><p>把对应的变量改为你自己的目录路径即可</p><h4 id="2-GOBIN"><a href="#2-GOBIN" class="headerlink" title="2.GOBIN"></a>2.GOBIN</h4><p>这个可以不做，我做这个主要是让后期<code>install</code>的文件和<code>bin</code>目录下的开发者工具相隔离</p><h4 id="3-修改GOCACHE"><a href="#3-修改GOCACHE" class="headerlink" title="3.修改GOCACHE"></a>3.修改GOCACHE</h4><p>我也是简单地修改了一下<code>GOCACHE</code>,我是放在<code>GOPATH</code>之下的</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">go env <span class="hljs-literal">-w</span> GOCACHE=yourpath<br></code></pre></td></tr></table></figure><h2 id="4-设置代理"><a href="#4-设置代理" class="headerlink" title="4.设置代理"></a>4.设置代理</h2><p><a href="https://cloud.tencent.com/developer/article/1773630">https://cloud.tencent.com/developer/article/1773630</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
