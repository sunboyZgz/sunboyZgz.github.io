<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rust-move-borrow</title>
    <link href="/2022/10/16/rust-move-borrow/"/>
    <url>/2022/10/16/rust-move-borrow/</url>
    
    <content type="html"><![CDATA[<h1 id="一题看所有权问题"><a href="#一题看所有权问题" class="headerlink" title="一题看所有权问题"></a>一题看所有权问题</h1><h2 id="写文原因"><a href="#写文原因" class="headerlink" title="写文原因"></a>写文原因</h2><p>众所周知，在rust中所有权问题是一个非常重要的问题，他直接影响了一个程序的性能。另外配合上rust的检查器+rust的生命周期，他能在很多情况下及时反馈出程序的潜在问题，这篇文章将会用一个leetcode题目分析一下如何在编写程序的时候进行合理的思考。  </p><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists">https://leetcode.cn/problems/merge-two-sorted-lists</a></p><p><strong>【注】：</strong>本文并不是算的讲解，最好在能够思考出算法的实现方案下阅读。</p><h2 id="move与borrow"><a href="#move与borrow" class="headerlink" title="move与borrow"></a>move与borrow</h2><p>关于变量表达式的问题：<a href="https://doc.rust-lang.org/reference/expressions.html?highlight=move#place-expressions-and-value-expressions">https://doc.rust-lang.org/reference/expressions.html?highlight=move#place-expressions-and-value-expressions</a></p><p><strong>关于这页相关理论，下面这句话尤为需要注意，这句话在循环中能起到非常大的作用。</strong></p><blockquote><p>After moving out of a place expression that evaluates to a local variable, the location is deinitialized and cannot be read from again until it is reinitialized</p></blockquote><p>关于所有权的理论在这个链接中有详细的说明：<a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</a></p><p>下面我们简单的讲一下，接下来需要的理论</p><h4 id="1-所有权"><a href="#1-所有权" class="headerlink" title="1.所有权"></a>1.所有权</h4><p>对于一个临时且不是reference的变量我们可以认为我们拥有了它的所有权，此时对于我们声明的变量我们可以认为我们拥有了它的所有权，变量内存地址位置就会开辟出装载该变量所需要的内存空间。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="2-可变性"><a href="#2-可变性" class="headerlink" title="2.可变性"></a>2.可变性</h4><p>默认情况下rust视为我们不能对变量的内存空间进行操作，即使拥有所有权依旧需要<code>mut</code>pattern来提供可操作该区域内存空间的能力。即使你是房子的主人，也需要先用钥匙打开房子的门。嗯！没错，就是这种感觉。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>node.next = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>)));<br><span class="hljs-comment">//下面是没有mut编译器的报错</span><br><span class="hljs-comment">//cannot assign to `node.next`, as `node` is not declared as mutable cannot assign</span><br></code></pre></td></tr></table></figure><h4 id="3-不可变借用"><a href="#3-不可变借用" class="headerlink" title="3.不可变借用"></a>3.不可变借用</h4><p>借用这个概念真的非常贴近我们日常的表述了，就是东西我借给你了，但是你要原模原样得还给我。</p><p>在代码中，我们可以理解为将数据内存空间的读取能力分发给了其他变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">node2</span> = &amp;node;<br></code></pre></td></tr></table></figure><h4 id="4-可变借用"><a href="#4-可变借用" class="headerlink" title="4.可变借用"></a>4.可变借用</h4><p>与不可变借用相似，提供了可修改原有数据内存空间的能力。东西仍然在我这里，但是你修改之后，我也这边也产生了变化。</p><p>但是在这种借用前，这个东西首先是能够修改的，也就是绑定了<code>mut</code> pattern。另外可变借用的操作符号是<code>&amp;mut</code>。</p><p>这篇官文也说明了使用可变借用的其他性质：<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">node</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;node.val);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">node2</span> = &amp;<span class="hljs-keyword">mut</span> node;<br>node2.val = <span class="hljs-number">2</span>;<br><span class="hljs-title function_ invoke__">println</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, node.val);<br></code></pre></td></tr></table></figure><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>优秀的代码在产出前一定有很多的思考，但是在产出之前rust会让你增加对于代码结构编织的思考，不然你就可能只能将伪代码保存在你的脑子里了。对于我们这样的新手如果不认真思考的话就不是项目规模化后的问题了，而是能不能让编译器爸爸放你过关😂。</p><h4 id="算法简析：对于两条链合并情况的分析"><a href="#算法简析：对于两条链合并情况的分析" class="headerlink" title="算法简析：对于两条链合并情况的分析"></a>算法简析：对于两条链合并情况的分析</h4><ol><li>两条空链</li><li>只有一条 链&#x2F;子链 存在</li><li>两条 链&#x2F;子链 都存在</li></ol><h4 id="将思路具体化"><a href="#将思路具体化" class="headerlink" title="将思路具体化"></a>将思路具体化</h4><p>1.创建防止第一个节点就是NULL而无法正确执行算法的辅助节点</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">head</span> = ListNode::<span class="hljs-title function_ invoke__">new</span>(-<span class="hljs-number">101</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">cur</span> = &amp;<span class="hljs-keyword">mut</span> head; <span class="hljs-comment">//cur变量的内存地址中应该要记录当前连接到的最后一个节点，另外最后一个点就是cur记录的是一个地址，但是我们在拼接时需要修改这个地址，而不单单是修改地址所指的数据空间。</span><br>...<br>head.next<br></code></pre></td></tr></table></figure><p>2.在两条子链都存在的情况下进行的拼接操作</p><p>While let expression:<a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops">https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops</a></p><p>Match expression: <a href="https://doc.rust-lang.org/reference/expressions/match-expr.html">https://doc.rust-lang.org/reference/expressions/match-expr.html</a></p><blockquote><p>If the scrutinee expression is a <a href="https://doc.rust-lang.org/reference/expressions.html#place-expressions-and-value-expressions">value expression</a>, it is first evaluated into a temporary location, and the resulting value is sequentially compared to the patterns in the arms until a match is found.</p></blockquote><p>针对这个问题我们可以做出以下两种思考</p><p>思考一：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(n1), <span class="hljs-title function_ invoke__">Some</span>(n2)) = (&amp;list1, &amp;list2) &#123;<span class="hljs-comment">//在这里使用借用，这样不会导致list的所有权转移到这里，然后后面就会无法访问list1，list2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>思考二：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(n1), <span class="hljs-title function_ invoke__">Some</span>(n2)) = (list1, list2) &#123;<span class="hljs-comment">//这就是转移所有权并使用tuple pattern进行结构赋值，这样n1，n2所有权也在当前作用域下。但是使用这种方案我们需要进行一点修改，因为这样的所有权解构会造成list1，list2无法在后续访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>3.取小的节点进行拼接</p><p>思考一的body</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(n1), <span class="hljs-title function_ invoke__">Some</span>(n2)) = (&amp;list1, &amp;list2) &#123;<span class="hljs-comment">//list1在未重分配前会飘红</span><br><span class="hljs-keyword">if</span> n1.val &lt; n2.val &#123;<br>      cur.next = list1; <span class="hljs-comment">//1.这里move进去，当我们写到这里在IDE环境我们会发现 &amp;list1 这里出现 borrow after move的飘红报错，这时请用好上面说到的 重分配理论，请自信使用为list1分配一个所有权的value的代码</span><br>      cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();  <span class="hljs-comment">//因为cur是一个可变借用，所以需要一个可变借用</span><br>      list1 = cur.next.<span class="hljs-title function_ invoke__">take</span>(); <span class="hljs-comment">//2.从cur.next这里move出来，并未list1重分配</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//相同道理</span><br>  &#125;<br>&#125;<br>cur.next = <span class="hljs-keyword">if</span> list1.<span class="hljs-title function_ invoke__">is_some</span>() &#123; list1 &#125; <span class="hljs-keyword">else</span> &#123; list2 &#125;;<br></code></pre></td></tr></table></figure><p>思考二的body</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-keyword">if</span> list1.<span class="hljs-title function_ invoke__">is_some</span>() &amp;&amp; list2.<span class="hljs-title function_ invoke__">is_some</span>() &#123;<span class="hljs-comment">//这么做是为了防止while let最后一次解构引起后续list1，list2无法borrow的问题</span><br>        <span class="hljs-keyword">let</span> (n1, n2) = (list1.<span class="hljs-title function_ invoke__">unwrap</span>(), list2.<span class="hljs-title function_ invoke__">unwrap</span>());<br>        <span class="hljs-keyword">if</span> &amp;n1.val &lt; &amp;n2.val &#123;<br>            cur.next = <span class="hljs-title function_ invoke__">Some</span>(n1);<br>            cur = cur.next.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            list1 = cur.next.<span class="hljs-title function_ invoke__">take</span>();<br>            list2 = <span class="hljs-title function_ invoke__">Some</span>(n2)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//相同道理</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br>cur.next = <span class="hljs-keyword">if</span> list1.<span class="hljs-title function_ invoke__">is_some</span>() &#123; list1 &#125; <span class="hljs-keyword">else</span> &#123; list2 &#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在rust代码的编写中我们需要更多地去思考，而不是过度依赖于编译器，要做到有理有据。过度依赖编译器很容易不自信啦。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮点数总结</title>
    <link href="/2022/10/12/float-numeric/"/>
    <url>/2022/10/12/float-numeric/</url>
    
    <content type="html"><![CDATA[<h1 id="浮点数与其构成"><a href="#浮点数与其构成" class="headerlink" title="浮点数与其构成"></a>浮点数与其构成</h1><h2 id="为什么学习浮点数？"><a href="#为什么学习浮点数？" class="headerlink" title="为什么学习浮点数？"></a>为什么学习浮点数？</h2><p>对于浮点数，我一直都是抱着深入其基础实现的想法，但是之前一直没有进行底层知识的学习。终于在这几周，我开始恶补底层的知识，虽然对于大部分人来说浮点数以及对于浮点数的操作都不需要知道其内部的实现，不过我认为我们可以不用去实现，但是作为知识面我们至少还是要了解一二的。</p><p>比如在程序语言中经常可以看到的问题：0.1 + 0.2 !&#x3D; 0.3 问题。</p><p>当然上面这个问题归根到底主要是小数在二进制中的计算方案采用一种乘2取1的方法</p><h2 id="浮点数的基本格式"><a href="#浮点数的基本格式" class="headerlink" title="浮点数的基本格式"></a>浮点数的基本格式</h2><p>我们知道计算机底层对于数的表示都是 <code>0101xxxx...</code> 这样的二进制码，在整数的二进制中我们将有符号数的存储单元(这里所说的存储单元与int32 &#x3D; 4 bytes对应)最高位置设为符号位，1表示整个数为负数。</p><h4 id="十进制如何进行浮点数表示"><a href="#十进制如何进行浮点数表示" class="headerlink" title="十进制如何进行浮点数表示"></a>十进制如何进行浮点数表示</h4><p>例如：</p><ul><li>0.000001 &#x3D; 1.0 * 10^-6</li><li>30000 &#x3D; 3.0 * 10^4</li></ul><h4 id="二进制浮点数表示"><a href="#二进制浮点数表示" class="headerlink" title="二进制浮点数表示"></a>二进制浮点数表示</h4><p>所以我们可以对这种认识进行二进制翻译</p><p>1.0 * 10^6 &#x3D; 1 * binary(10^-6)</p><p>3.0 * 10^4 &#x3D; 11 * binary(10^4)</p><h4 id="存储在计算机里的二进制浮点数表示"><a href="#存储在计算机里的二进制浮点数表示" class="headerlink" title="存储在计算机里的二进制浮点数表示"></a>存储在计算机里的二进制浮点数表示</h4><p>但是我们不能将一个表达式直接存储在计算机中，虽然我认为是有办法可以做到，但是这并不划算，所以我们需要一套性价比更高的方案。</p><p>于是乎我们就需要去制定一套存储格式，去规定浮点数的正负，指数次数，以及实际有效的数。</p><p>另外我们也可以发现对于30000这样的数字我们也可以表示为30 * 10^3 &#x3D;&#x3D; 3 * 10^4,而我们称等号右边是对等号左边的规格化，同理二进制也可以做这样的规格化，因为二进制只有0和1，所以我们只会在左边数为1的时候进行一次移位，这样我们省下这一位的空间了，为浮点数提供更大的表达范围。</p><p>浮点数的三部分：<code>符号位</code>，<code>指数段</code>，<code>尾数段</code>。值得一提的是，浮点数的符号位这种表示与整数符号位的设计思维并不一样。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl">浮点数 = (-<span class="hljs-number">1</span>)^<span class="hljs-variable">S</span> * <span class="hljs-function"><span class="hljs-title">fraction</span>(尾数) * <span class="hljs-number">2</span>^<span class="hljs-title">exponent</span>(指数)</span><br></code></pre></td></tr></table></figure><p>以下是 IEEE754标准的f32</p><table><thead><tr><th>31</th><th>30</th><th>29</th><th>28</th><th>27</th><th>26</th><th>25</th><th>24</th><th>23</th><th>22</th><th>21</th><th>20</th><th>19</th><th>18</th><th>17</th><th>16</th><th>15</th><th>14</th><th>13</th><th>12</th></tr></thead><tbody><tr><td>符号位</td><td>exponent</td><td></td><td></td><td></td><td></td><td></td><td></td><td>exponent</td><td>fraction</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>fraction</td></tr></tbody></table><h2 id="具体的计算"><a href="#具体的计算" class="headerlink" title="具体的计算"></a>具体的计算</h2><p>1.如果0，32位存储全为0</p><p>2.如果不为零，进行上述的计算方案，负数在符号位置1，进行二进制的计算将思维中的十进制浮点数转换为二进制。</p><p>计算机底层如何处理我不清楚，这里我根据浮点数的算数处理留下以下结论：</p><ul><li>如果存在整数位，exponent &#x3D; 整数位的位数 - 1, fraction 扔掉最高位的1</li><li>如果不存在整数位，我们需要找到小数位二进制的第一个1，1前面的0 以 exponent &#x3D; 0的数量 来表示</li></ul><h2 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h2><p>为了更简单的得到反馈：我使用了浏览器为载体，下面是我的代码仓库</p><p><a href="https://github.com/sunboyZgz/interesting/blob/main/src/components/009.vue">https://github.com/sunboyZgz/interesting/blob/main/src/components/009.vue</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机底层知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awesome-rust-1(IdentifierPattern)</title>
    <link href="/2022/09/23/awesome-rust-1/"/>
    <url>/2022/09/23/awesome-rust-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust-IdentifierPattern-ref"><a href="#Rust-IdentifierPattern-ref" class="headerlink" title="Rust IdentifierPattern - ref"></a>Rust <em>IdentifierPattern</em> - ref</h1><h2 id="rust-启动！"><a href="#rust-启动！" class="headerlink" title="rust 启动！"></a>rust 启动！</h2><p>这是awesome-rust的第一篇文章，所有文章的内容都将以问题由来+问题解决+官文链接的方案来解释（当然由于个人能力问题官文中的内容可能不能理解到位，请海涵）。</p><p>rust的官方reference：<a href="https://doc.rust-lang.org/reference/introduction.html">https://doc.rust-lang.org/reference/introduction.html</a> 。我认为所有学习rust的同学都应该知道这份参考手册的存在，这份手册真的是太棒辣。</p><h2 id="IdentifierPattern"><a href="#IdentifierPattern" class="headerlink" title="IdentifierPattern"></a><em>IdentifierPattern</em></h2><h4 id="问题产出"><a href="#问题产出" class="headerlink" title="问题产出"></a>问题产出</h4><p>我在<code>codewars</code>平台进行练习题目 [ <a href="https://www.codewars.com/kata/52bef5e3588c56132c0003bc">https://www.codewars.com/kata/52bef5e3588c56132c0003bc</a> ] 后与他人代码对比后发现了 <code>ref</code> 正确使用的姿势之一。</p><p>这里值得提一嘴的是，对于刚步入一门新语言的“萌新”，<code>codewars</code>的题目推荐非常适合用于熟悉语言特点与语言标准库。</p><p>下面这个是Node的struct，同时Node并没有实现<code>Clone</code>或者<code>Copy</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    value: <span class="hljs-type">u32</span>,<br>    left: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;,<br>    right: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代码对比"><a href="#代码对比" class="headerlink" title="代码对比"></a>代码对比</h4><p><strong>我的代码</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">traverse</span>(last_nodes: &amp;<span class="hljs-keyword">mut</span> VecDeque&lt;&amp;Node&gt;, result: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt;) &#123;<br>    <span class="hljs-keyword">if</span> last_nodes.<span class="hljs-title function_ invoke__">len</span>() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">childrens</span> = VecDeque::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(node) = last_nodes.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>      result.<span class="hljs-title function_ invoke__">push</span>(node.value);<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(n) = &amp;node.left &#123;<br>          childrens.<span class="hljs-title function_ invoke__">push_back</span>(n.<span class="hljs-title function_ invoke__">as_ref</span>());<br>      &#125;<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(n) = &amp;node.right &#123;<br>          childrens.<span class="hljs-title function_ invoke__">push_back</span>(n.<span class="hljs-title function_ invoke__">as_ref</span>());<br>      &#125;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">traverse</span>(&amp;<span class="hljs-keyword">mut</span> childrens, result)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其他人的代码</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">tree_by_levels_best</span>(root: &amp;Node) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">queue</span>: VecDeque&lt;&amp;Node&gt; = VecDeque::<span class="hljs-title function_ invoke__">from</span>([root]);<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(n) = queue.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>        result.<span class="hljs-title function_ invoke__">push</span>(n.value);<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> l) = n.left &#123; <span class="hljs-comment">//关键的不同点</span><br>            queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> r) = n.right &#123;<br>            queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*r);<br>        &#125;<br>    &#125;<br>    result<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>由于平时常用的<code>IdentifierPattern</code>多是 <code>mut</code>,而这里出现了 <code>ref</code>，虽然从字面上或者代码上我们可以理解 <code>ref</code> 的作用，但是我还是想要找出使用这个 pattern 的条件。 </p><p>官文链接：<a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">https://doc.rust-lang.org/reference/patterns.html#identifier-patterns</a> 。</p><p>官文中明确指出了，标识符的pattern默认的两种做法</p><p>1.会优先考虑把标识符所表示的变量绑定到它所依赖的值的一份copy上。</p><p>2.会优先考虑把依赖数据move到变量中</p><p>关于copy，当然就是实现 Rust的 <code>Copy Trait</code>咯。</p><p>关于move，这里贴出官文的链接：<a href="https://doc.rust-lang.org/reference/expressions.html?highlight=move#moved-and-copied-types">https://doc.rust-lang.org/reference/expressions.html?highlight=move#moved-and-copied-types</a> ，这里面提出了能够move的四种情况。在这里我认为不能进行move的主要原因是第一种情况</p><blockquote><p><a href="https://doc.rust-lang.org/reference/variables.html">Variables</a> which are not currently borrowed.</p></blockquote><p>这里摘出关键的不同点进行拆分</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">ref</span> l) = n.left &#123; <br>    queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有 <code>ref</code>，代码会以以下方式呈现，当rust的编译器进行checker时会发现我们的Node节点没有Copy的实现，同时在<code>Some(l) = n.left</code>这个<code>destructuring subpatterns</code>中发现l依赖的数据是<code>Box&lt;Node&gt;</code> 关于<code>Box</code>它相当于是一种共享型的能力，因此也并不满足<code>move</code>触发的条件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(l) = n.left &#123; <br>    queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有了上面的<code>ref</code>我们会改变 identifier pattern 的默认绑定方式，相当于采用了下面的做法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(l) = &amp;n.left &#123; <br>    queue.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*l);<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，我在这个学习的过程中还发现了一个有趣的问题，就是rust的自动类型推测系统与实际需要效果的差异。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">queue</span>: VecDeque&lt;&amp;Node&gt; = VecDeque::<span class="hljs-title function_ invoke__">from</span>([root]); <span class="hljs-comment">//这里是显示类型</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">childrens</span> = VecDeque::<span class="hljs-title function_ invoke__">new</span>(); <span class="hljs-comment">//这里会infer出 VecDeque&lt;&amp;Box&lt;Node&gt;&gt;,与实际需求略有差异</span><br>...<br>childrens.<span class="hljs-title function_ invoke__">push_back</span>(&amp;*n);<br>...<br></code></pre></td></tr></table></figure><p>欢迎各位前来指点，这是我的SO Question: <a href="https://stackoverflow.com/questions/73824648/rust-why-compiler-infers-a-different-type-beyond-our-expection">https://stackoverflow.com/questions/73824648/rust-why-compiler-infers-a-different-type-beyond-our-expection</a></p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文入门rust iterator</title>
    <link href="/2022/09/21/rust-iter/"/>
    <url>/2022/09/21/rust-iter/</url>
    
    <content type="html"><![CDATA[<h1 id="一文入门rust-iterator"><a href="#一文入门rust-iterator" class="headerlink" title="一文入门rust iterator"></a>一文入门rust iterator</h1><h2 id="1-本文由来"><a href="#1-本文由来" class="headerlink" title="1.本文由来"></a>1.本文由来</h2><p>秉承一贯的做法，我还是想说说为什么我会想要写下这篇文章。起因是这样的，作为一名刚想rust的新手，我找到了一个锻炼rust语法比较好的平台<code>codewars</code>，当然我在之前就已经阅读了rust最优质的文章资源：<a href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">https://doc.rust-lang.org/book/ch01-00-getting-started.html</a> ，以及使用过<code>rustlings</code>进行了一些的知识点检查。在锻炼的过程中，我发现那些简短而优雅的代码不仅仅是逻辑运用更加熟练，同时他们对于标准库的掌握与熟悉程度也是非常得高。</p><h2 id="2-一个简单的入门级rust-iterator"><a href="#2-一个简单的入门级rust-iterator" class="headerlink" title="2.一个简单的入门级rust iterator"></a>2.一个简单的入门级rust iterator</h2><h4 id="1-让我们自己进行便利操作我们会怎么做？"><a href="#1-让我们自己进行便利操作我们会怎么做？" class="headerlink" title="1.让我们自己进行便利操作我们会怎么做？"></a>1.让我们自己进行便利操作我们会怎么做？</h4><p>假设我们有以下这样的结构，我们如果要遍历并对每个元素进行相应的操作时应该怎么做？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    elms: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">struct Bag&lt;T&gt; (Vec&lt;T&gt;) 这种结构也可以，主要是为了不直接使用Vec，只使用他的装载功能</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="2-大部分人可能的做法"><a href="#2-大部分人可能的做法" class="headerlink" title="2.大部分人可能的做法"></a>2.大部分人可能的做法</h4><p>如果让我们自己来进行实现，我们认为对于一个新手来说最容易想到的就是，实现可以传入闭包的“方法”。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">traverse</span>&lt;F&gt;(&amp;<span class="hljs-keyword">self</span>, f: F)<br>    <span class="hljs-keyword">where</span><br>        F: <span class="hljs-title function_ invoke__">Fn</span>(T, <span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> (),<br>    &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-title function_ invoke__">f</span>(<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">get</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">clone</span>(), i);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-问题分析"><a href="#3-问题分析" class="headerlink" title="3.问题分析"></a>3.问题分析</h4><p>以上做法没有问题，并且能够实现特别多的需求但是上面的做法在不连续的遍历中就显得别不是那么得灵活。如果想要一种可以完全控制其遍历进度并且充分灵活的方案就需要迭代器的加入。</p><p>跟随着官网对于迭代器的实现，我在最开始实现了以下一个错误案例。</p><p><strong>注意：</strong>这是错误案例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    elms: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>    idx: <span class="hljs-type">usize</span>,<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Copy</span>&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.idx &lt; <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-keyword">self</span>.idx).<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">clone</span>());<br>            <span class="hljs-keyword">self</span>.idx += <span class="hljs-number">1</span>;<br>            result<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个问题中我们会发现，我们可以进行迭代，但是问题是我们的迭代只能遍历一次，因为<code>idx</code>的索引值会越界。这个时候有人会说在遍历到最后一个的时候重置索引值，这样可行但是如果我们同时需要两个Bag的迭代器呢？ok，有人会说为<code>Bag</code>提供<code>Clone Trait</code>，但是这样的问题就是不必要的内存开辟。</p><p>所以对于<code>Iterator</code>，我们应该将他看成是一个独立的个体，但同时他又必须与需要遍历的对象保持一定的联系。</p><h4 id="4-最终的简单方案"><a href="#4-最终的简单方案" class="headerlink" title="4.最终的简单方案"></a>4.最终的简单方案</h4><p>1.首先我们需要一个独立的遍历器</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BagIter</span>&lt;T&gt; &#123;<br>    idx: <span class="hljs-type">usize</span>,<span class="hljs-comment">//这是独立的访问索引</span><br>    elms: Rc&lt;RefCell&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt;&gt;, <span class="hljs-comment">//记录我们需要遍历的context</span><br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; BagIter&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elms: Rc&lt;RefCell&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt;&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        BagIter &#123; idx: <span class="hljs-number">0</span>, elms &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">BagIter</span>&lt;T&gt;<br><span class="hljs-keyword">where</span><br>    T: <span class="hljs-built_in">Copy</span>,<br>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">elms</span> = <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">borrow</span>();<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.idx &lt; elms.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>            <span class="hljs-literal">true</span> =&gt; <span class="hljs-keyword">match</span> elms.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-keyword">self</span>.idx) &#123;<br>                <span class="hljs-title function_ invoke__">Some</span>(&amp;x) =&gt; &#123;<br>                    <span class="hljs-keyword">self</span>.idx += <span class="hljs-number">1</span>;<br>                    <span class="hljs-title function_ invoke__">Some</span>(x)<br>                &#125;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>            &#125;,<br>            <span class="hljs-literal">false</span> =&gt; <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.实现一个 <code>iter</code> 每次调用 <code>iter()</code>生成一个新的独立遍历器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    elms: Rc&lt;RefCell&lt;<span class="hljs-type">Vec</span>&lt;T&gt;&gt;&gt;,<br>&#125;<br><span class="hljs-comment">//can only put things into Bag</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Bag&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, item: T) &#123;<br>        <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(item)<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> Bag&lt;T&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">elms</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[]));<br>        Bag &#123; elms: elms &#125;<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">size</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>        <span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">borrow</span>().<span class="hljs-title function_ invoke__">len</span>()<br>    &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">iter</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> BagIter&lt;T&gt; &#123;<br>        BagIter::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.elms.<span class="hljs-title function_ invoke__">clone</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-满足你的-for-…-in-expression"><a href="#5-满足你的-for-…-in-expression" class="headerlink" title="5.满足你的 for … in expression"></a>5.满足你的 for … in expression</h4><p>众所周知在一套完美的第三方库或者标准库下，rust为第三方开发者提供的体验是非常优越的，其主要源自<code>Trait</code>以及一些隐式编译的实现。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Copy</span>&gt; <span class="hljs-built_in">IntoIterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Bag</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">IntoIter</span> = BagIter&lt;T&gt;;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into_iter</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::IntoIter &#123;<br>        <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">iter</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>IntoIterator</code>可以让你的代码在编译时生成对于self.iter()的迭代器。另外根据<code>IntoIterator for &amp;mut Bag&lt;T&gt;</code>, <code>IntoIterator for &amp; Bag&lt;T&gt;</code>的不同也可以实现不同的借用、修改迭代器，当然咯，这个都是得重写一份逻辑的。</p><p>ok，希望这篇入门能够帮你建立如何编写迭代器的认知。</p>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>newbie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片像素化</title>
    <link href="/2022/09/14/pixel-image/"/>
    <url>/2022/09/14/pixel-image/</url>
    
    <content type="html"><![CDATA[<h1 id="像素化一张图片"><a href="#像素化一张图片" class="headerlink" title="像素化一张图片"></a>像素化一张图片</h1><h2 id="1-为什么我会想要一种像素风格的图片"><a href="#1-为什么我会想要一种像素风格的图片" class="headerlink" title="1.为什么我会想要一种像素风格的图片"></a>1.为什么我会想要一种像素风格的图片</h2><p>因为我前段时间想要DIY一个便携的显示器，直接一个面板+驱动的方案看上去不但造型不行，而且不易携带。于是我就在网上搜索，我发现了可自定义化程度最高的就是面板+驱动+微积木方案了，但是自定义的像素风格图片去哪找呢，于是我就想要一个这样的效果。</p><h2 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h2><p>这边我采用的是在浏览器这个平台进行操作，一个原因是使用其他语言我需要去学习对应的库，第二个就是在浏览器这个平台上我能够更快地得到反馈。</p><h4 id="1-关于屏幕上的像素点"><a href="#1-关于屏幕上的像素点" class="headerlink" title="1.关于屏幕上的像素点"></a>1.关于屏幕上的像素点</h4><p>通过分辨率的设定，我们可以在屏幕上划分出不同的行、列可显示的像素数，比如同样的<code>300 * 300</code></p><p>像素的图片在，<code>2560 * 1440</code> 和 <code>1920 * 1080</code>的分辨率下默认的显示大小是不同，这种时候屏幕一格的像素大小就产生了差异。</p><h4 id="2-曾经与现在"><a href="#2-曾经与现在" class="headerlink" title="2.曾经与现在"></a>2.曾经与现在</h4><p>现在的屏幕往往在最低的分辨率下，屏幕划分好的一个像素点也比以前的屏幕要小了不知道多少倍，目前我们可以假设：一个曾经的像素点 &#x3D; 一个现在的像素点 * 9 * 9。</p><h4 id="3-屏幕展示像素数量多的好处"><a href="#3-屏幕展示像素数量多的好处" class="headerlink" title="3.屏幕展示像素数量多的好处"></a>3.屏幕展示像素数量多的好处</h4><p>显而易见，像素数就是一个区域色彩展示的层度，更多的像素数可以体现出更加细节的处理。因为像素是方格的，越小的像素点可以是的方格与方格之间过渡更加的平滑。整体的细节处理就更加优秀。</p><h4 id="4-关于我们使用操作系统放大图片"><a href="#4-关于我们使用操作系统放大图片" class="headerlink" title="4.关于我们使用操作系统放大图片"></a>4.关于我们使用操作系统放大图片</h4><p>关于这一点，我的理解是：操作系统放大图片的处理其实是对图片中每个实际像素的逻辑扩大，也就是图片源文件其实是不变的，但是我们再放大时其实是在使用临时的图片文件，然后我们对源文件的每个像素进行采样并进行新的映射，比如原来的 1个像素映射成 2*2个像素区的逻辑像素。</p><h2 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3.具体实现"></a>3.具体实现</h2><p>看了上面的操作，实际上我们就可以有初步的方案了，也就是对图片进行缩小的采样与扩大的映射。</p><h4 id="1-使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）"><a href="#1-使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）" class="headerlink" title="1.使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）"></a>1.使用浏览器与操作系统的能力进行操作。（js版，学习逻辑直接跳过）</h4><ol><li>将图片缩小并画到画布上。</li><li>将画布上的图片画到临时图片DOM上。</li><li>将临时的图片DOM画到与图片原来尺寸相同甚至更大的画布上。</li></ol><p>在上述的操作中图片的采样以及映射均由浏览器为我们实现。</p><p>具体代码：scale为采样间隔或者说缩放比例，影响采样频率。</p><p><img src="/2022/09/14/pixel-image/js.png" alt="image-20220914130850306"></p><h4 id="2-使用自己实现的逻辑方案。"><a href="#2-使用自己实现的逻辑方案。" class="headerlink" title="2.使用自己实现的逻辑方案。"></a>2.使用自己实现的逻辑方案。</h4><p>1.每隔多少行多少列(gap)进行一次采样</p><p>2.对采样后的像素进行映射,映射大小为 1像素 &#x3D; <code>gap * gap</code> 像素</p><p>因为图片的资源占用量比较大。</p><p>具体可以参考：<a href="https://github.com/sunboyZgz/pixel-image/blob/56c54ccdbc526c72a7ef607b41a1bb1f07831aff/packages/pixel-image/src/main.ts#L47">https://github.com/sunboyZgz/pixel-image/blob/56c54ccdbc526c72a7ef607b41a1bb1f07831aff/packages/pixel-image/src/main.ts#L47</a></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的博客</title>
    <link href="/2022/08/24/newblog/"/>
    <url>/2022/08/24/newblog/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-Page-Custom-Domain"><a href="#Github-Page-Custom-Domain" class="headerlink" title="Github Page-Custom Domain"></a>Github Page-Custom Domain</h1><h2 id="1-原因"><a href="#1-原因" class="headerlink" title="1.原因"></a>1.原因</h2><p>众所周知<code>github</code>提供了一个<code>github-page</code>的服务，但是有些人很困惑为什么只能部署一个项目，但其实并不是这样的。<code>github-page</code>setting中的<code>custom domain</code>能很好的利用这个服务为我们部署多个项目。</p><p>本质上是利用<code>github</code>为每一个用户提供的一个个人站点(<code>username.github.io</code>)（相当于提供了静态服务器已经一个绑定的域名），进行<code>DNS</code>映射这样就能在剩下服务器的时候进行一些个人项目部署。</p><h2 id="2-具体操作"><a href="#2-具体操作" class="headerlink" title="2.具体操作"></a>2.具体操作</h2><h4 id="1-首先我们需要一个域名"><a href="#1-首先我们需要一个域名" class="headerlink" title="1.首先我们需要一个域名"></a>1.首先我们需要一个域名</h4><p>如何获取域名自行解决，我是在阿里收购的域名提供商那边买的</p><h4 id="2-进行域名解析，使username-github-io与你购买的一级域相映射"><a href="#2-进行域名解析，使username-github-io与你购买的一级域相映射" class="headerlink" title="2.进行域名解析，使username.github.io与你购买的一级域相映射"></a>2.进行域名解析，使<code>username.github.io</code>与你购买的一级域相映射</h4><p>这一步我是在阿里云的域名解析里做的，其他方式大同小异</p><p>1.在域名解析里采用CNAME的形式将一个对我自己的域名（zhugezhen.cn)和<code>sunboyzgz.github.io</code></p><p>进行一个映射。</p><p>下一步在<strong>setting</strong>中的<strong>pages</strong>设置中操作</p><p>2.在<strong>Build and deployment</strong>的<strong>source</strong>选项下选择<strong>deploy from a branch</strong>，然后选择你要部署的目录，也就是你希望展示的<code>index.html</code>所存在的目录。不同于<code>deploy from a branch</code>github也为我们提供了一个<strong>github actions</strong>的选择，这里就是后面要讲的<code>github actions</code>。</p><p>3.选择一个<code>custom domain</code>这里就是我们自己购买的域名填入即可</p><p><strong>note</strong>!!: 使用二级域名与<code>custom domain</code>相互映射的方案我们可以部署多个项目，并且这些项目并不需要都在<code>username.github.io</code>这个仓库下, 不过二级域名也是直接映射到<code>username.github.io</code>这个域。</p><p>这里假设我们的生成的二级域名是<code>book.zhugezhen.cn</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//域名解析中 CNAME形式，当然也可以使用ip的形式</span><br>zhugezhen<span class="hljs-selector-class">.cn</span> -&gt; sunboyzgz<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br>book<span class="hljs-selector-class">.zhugezhen</span><span class="hljs-selector-class">.cn</span> -&gt; sunboyzgz<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><br><span class="hljs-comment">//setting pages CNAME</span><br>custom domain save <span class="hljs-selector-tag">a</span> zhugezhen<span class="hljs-selector-class">.cn</span><br>custom domain save <span class="hljs-selector-tag">a</span> book<span class="hljs-selector-class">.zhugezhen</span>.cn<br></code></pre></td></tr></table></figure><h1 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h1><h2 id="1-原因-1"><a href="#1-原因-1" class="headerlink" title="1.原因"></a>1.原因</h2><p>本质上，这就是github为我们提供的一个CI&#x2F;CD的能力</p><p>在<code>hexo</code>生成的blog项目中，我们虽然可以在本地进行<code>generate</code>然后将源代码同步到远程仓库的一个分支，然后再将需要展示的文件目录推送到另一个分支，但是这样会在每次操作时需要进行很多相同的重复操作。这项工作可以交给其他的工具进行比如<a href="https://github.com/marketplace/travis-ci">Travis CI</a>，我只是抱着学习的态度想要尝试一下<code>action</code>。</p><h2 id="2-如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案"><a href="#2-如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案" class="headerlink" title="2.如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案"></a>2.如果你是hexo可以看下去，不是请跳过，直接到参考链接部分找寻答案</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span> <span class="hljs-string">blog</span> <span class="hljs-string">to</span> <span class="hljs-string">gh-pages</span>  <span class="hljs-comment">#这个是一个workflow name</span><br><span class="hljs-attr">on:</span> <span class="hljs-comment">#监听push的事件</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> <span class="hljs-comment">#对于main分支的push事件进行监听</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><span class="hljs-attr">jobs:</span> <span class="hljs-comment">#workflow中的jobs列表，jobs默认并发进行，如需相互依赖参考 need 属性的使用</span><br>  <span class="hljs-attr">generate-public:</span> <span class="hljs-comment">#job name</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span> <span class="hljs-comment">#运行的操作系统</span><br>    <span class="hljs-attr">steps:</span> <span class="hljs-comment">#操作步骤一步一步向下执行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span> <span class="hljs-comment">#使用checkout action，提供摘取仓库的能力</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span> <span class="hljs-comment">#一个配置node环境的action</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-number">16</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">packages</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-comment">#就像在本地用使用命令行一样</span><br>        <span class="hljs-comment">#这里要说一下，一个name下只能拥有一个run，有时可以像以下这样执行</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">generate</span> <span class="hljs-string">public</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npx</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">npx</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">CNAME</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&#x27;zhugezhen.cn&#x27;</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">./public/CNAME</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span> <span class="hljs-comment">#将目标目录push gh-pages分支的action</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br></code></pre></td></tr></table></figure><p>这个<code>github actions</code>的配置其实就已经代替了<code>hexo</code>文档中<a href="https://hexo.io/zh-cn/docs/github-pages%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E%E4%BA%86%E3%80%82">https://hexo.io/zh-cn/docs/github-pages的操作说明了。</a></p><h4 id="3-参考链接"><a href="#3-参考链接" class="headerlink" title="3.参考链接"></a>3.参考链接</h4><p>1.请先了解github actions:<a href="https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions">https://docs.github.com/cn/actions/learn-github-actions/understanding-github-actions</a></p><p>2.可以看看这里面的基本使用：<a href="https://github.com/jaywcjlove/github-actions">https://github.com/jaywcjlove/github-actions</a></p><p>3.这个不重要随便看看就好：<a href="https://github.blog/2022-08-10-github-pages-now-uses-actions-by-default/">https://github.blog/2022-08-10-github-pages-now-uses-actions-by-default/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新的篇章</title>
    <link href="/2022/08/23/My-new-way/"/>
    <url>/2022/08/23/My-new-way/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么会有这篇文章？"><a href="#为什么会有这篇文章？" class="headerlink" title="为什么会有这篇文章？"></a>为什么会有这篇文章？</h1><p>由于最近c盘紧张，我重装了一次系统同进行了一些卷容量的调整，因为最近没有怎么写过blog在进行格式化的时候将原来搭建的个人blog给清除了而且也没有做备份，git page上传的也只是一个经过处理后的html文件，所以我原来的blog文件都丢失了。因为我需要进行一些环境配置，所以写下了这篇文章。</p><h1 id="nodejs-npm-pnpm-配置"><a href="#nodejs-npm-pnpm-配置" class="headerlink" title="nodejs + npm + pnpm 配置"></a>nodejs + npm + pnpm 配置</h1><h2 id="1-windows-下安装nodejs"><a href="#1-windows-下安装nodejs" class="headerlink" title="1.windows 下安装nodejs"></a>1.windows 下安装nodejs</h2><p><a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>按照步骤安装即可，注意一下nodejs的安装目录即可</p><h2 id="2-配置npm"><a href="#2-配置npm" class="headerlink" title="2.配置npm"></a>2.配置npm</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config get prefix<br></code></pre></td></tr></table></figure><p>这条命令可以直接获取你的全局安装路径的前缀,这个前缀会用于</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm install <span class="hljs-literal">-g</span> xxxx<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;D:\Program Files\nodejs\node_global&quot;</span><br><br>npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\Program Files\nodejs\node_cache&quot;</span><br></code></pre></td></tr></table></figure><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><ol><li></li></ol><p><code>NODE_PATH    D:\Program Files\nodejs\node_global\node_modules</code></p><p><code>NODE_PATH</code> 用于进行全局的模块检索，例如加载npm全局下的<code>express</code>模块的时候</p><ol start="2"><li></li></ol><p><code>PATHD D:\Program Files\nodejs\node_global</code></p><h2 id="3-配置pnpm"><a href="#3-配置pnpm" class="headerlink" title="3.配置pnpm"></a>3.配置pnpm</h2><p>注意此项可以不用配置，在没有配置的情况下会在当前卷的根目录创建<code>node_modules</code>进行管理。</p><p>如果想要pnpm跨磁盘或者卷进行管理可以按如下设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pnpm config <span class="hljs-built_in">set</span> store<span class="hljs-literal">-dir</span> /path/to/.pnpm<span class="hljs-literal">-store</span><br></code></pre></td></tr></table></figure><p>参考链接：<a href="https://www.pnpm.cn/configuring%E3%80%81https://www.pnpm.cn/faq#store-path-is-not-specified">https://www.pnpm.cn/configuring、https://www.pnpm.cn/faq#store-path-is-not-specified</a></p><h4 id="4-修改install的镜像源"><a href="#4-修改install的镜像源" class="headerlink" title="4.修改install的镜像源"></a>4.修改install的镜像源</h4><p>这里就是淘宝的，要是用别的请搜索对应uri</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm config get registry<br></code></pre></td></tr></table></figure><h1 id="python-anaconda"><a href="#python-anaconda" class="headerlink" title="python anaconda"></a>python anaconda</h1><h2 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1.安装anaconda"></a>1.安装anaconda</h2><p>大陆用户推荐用清华的源进行安装解决安装包下载过慢的问题</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><h2 id="2-解决一些典型问题（待补充）"><a href="#2-解决一些典型问题（待补充）" class="headerlink" title="2.解决一些典型问题（待补充）"></a>2.解决一些典型问题（待补充）</h2><h4 id="1-pip-is-configured-with-locations-that-require-TLS-SSL"><a href="#1-pip-is-configured-with-locations-that-require-TLS-SSL" class="headerlink" title="1.[pip is configured with locations that require TLS/SSL]"></a>1.<code>[pip is configured with locations that require TLS/SSL]</code></h4><p><a href="https://stackoverflow.com/questions/45954528/pip-is-configured-with-locations-that-require-tls-ssl-however-the-ssl-module-in">https://stackoverflow.com/questions/45954528/pip-is-configured-with-locations-that-require-tls-ssl-however-the-ssl-module-in</a></p><p>一般我们都会把 python解释器和pip的路径加入环境，但是这里我们也需要加入第三个路径到环境中。（这里需要的原因可能是我在使用anaconda这个发型版本）</p><h2 id="3-修改local-cache"><a href="#3-修改local-cache" class="headerlink" title="3.修改local cache"></a>3.修改local cache</h2><p>下面这篇博文讲述了为什么需要这个cache</p><p><a href="https://www.techiediaries.com/python-pip-local-cache/">https://www.techiediaries.com/python-pip-local-cache/</a></p><p>配置方法:在<code>%HOME%</code>的<code>pip</code>目录下创建<code>pip.ini</code>（没有目录就自建一个）</p><p>找到<code>%HOME%</code>, 可以在文件资源管理器的路径栏输入<code>homepath</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[global]</span><br><span class="hljs-attr">cache-dir</span> = E:/languages/anaconda3/mypip/cache<br><span class="hljs-attr">log-file</span> = E:/languages/anaconda3/mypip/pip.log<br></code></pre></td></tr></table></figure><h2 id="4-修改pip安装源"><a href="#4-修改pip安装源" class="headerlink" title="4.修改pip安装源"></a>4.修改pip安装源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p><h4 id="5-检查一下配置情况"><a href="#5-检查一下配置情况" class="headerlink" title="5. 检查一下配置情况"></a>5. 检查一下配置情况</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">pip config list<br></code></pre></td></tr></table></figure><p><img src="/2022/08/23/My-new-way/image-20220823141458429.png" alt="result image"></p><h2 id="6-2022-x2F-8-x2F-27补充"><a href="#6-2022-x2F-8-x2F-27补充" class="headerlink" title="6. 2022&#x2F;8&#x2F;27补充:"></a>6. 2022&#x2F;8&#x2F;27补充:</h2><p>error:</p><blockquote><p>solving environment: failed with intitial frozen solve.Retrying with flexible solve.</p></blockquote><p><img src="/2022/08/23/My-new-way/image-20220827185106780.png" alt="error image"></p><h4 id="方案一：直面困难"><a href="#方案一：直面困难" class="headerlink" title="方案一：直面困难"></a>方案一：直面困难</h4><p>1.修改<code>conda</code>安装的镜像源为后续操作提速</p><p>具体修改方案可以参考清华提供的方案<code>.condarc</code></p><p>windows下使用命令生成在<code>%home%</code>目录下生成</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">conda config <span class="hljs-literal">--set</span> show_channel_urls yes<br></code></pre></td></tr></table></figure><p>然后将下方链接的中的配置复制到<code>.condarc</code>中</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/</a></p><p>2. </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">conda update <span class="hljs-literal">-all</span><br></code></pre></td></tr></table></figure><h4 id="方案二：曲线救国"><a href="#方案二：曲线救国" class="headerlink" title="方案二：曲线救国"></a>方案二：曲线救国</h4><p>使用pip install 安装，但是这样的话不能享受到conda create env带来的好处。但是真的简单。</p><h4 id="方案三：降级conda策略"><a href="#方案三：降级conda策略" class="headerlink" title="方案三：降级conda策略"></a>方案三：降级conda策略</h4><p>网上自搜</p><h1 id="go"><a href="#go" class="headerlink" title="go"></a>go</h1><p>这个就是最为简单的了</p><p>去官网找个安装包跟着官网走就好了：<a href="https://go.dev/doc/install">https://go.dev/doc/install</a></p><p>安装好之后推荐修改一下<code>GOPATH</code>和<code>GOBIN</code>,目前版本<code> GO111MODULE</code>默认是设为<code>on</code></p><p>小小的看一下<code>GOPATH</code>的目录结构，以及功能：<a href="http://c.biancheng.net/view/88.html">http://c.biancheng.net/view/88.html</a></p><h2 id="1-在（用户环境变量）中修改GOPATH"><a href="#1-在（用户环境变量）中修改GOPATH" class="headerlink" title="1.在（用户环境变量）中修改GOPATH"></a>1.在（用户环境变量）中修改GOPATH</h2><p>把对应的变量改为你自己的目录路径即可</p><h4 id="2-GOBIN"><a href="#2-GOBIN" class="headerlink" title="2.GOBIN"></a>2.GOBIN</h4><p>这个可以不做，我做这个主要是让后期<code>install</code>的文件和<code>bin</code>目录下的开发者工具相隔离</p><h4 id="3-修改GOCACHE"><a href="#3-修改GOCACHE" class="headerlink" title="3.修改GOCACHE"></a>3.修改GOCACHE</h4><p>我也是简单地修改了一下<code>GOCACHE</code>,我是放在<code>GOPATH</code>之下的</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">go env <span class="hljs-literal">-w</span> GOCACHE=yourpath<br></code></pre></td></tr></table></figure><h2 id="4-设置代理"><a href="#4-设置代理" class="headerlink" title="4.设置代理"></a>4.设置代理</h2><p><a href="https://cloud.tencent.com/developer/article/1773630">https://cloud.tencent.com/developer/article/1773630</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
